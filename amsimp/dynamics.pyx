#cython: linetrace=True
#distutils: define_macros=CYTHON_TRACE_NOGIL=1
#cython: language_level=3
"""
AMSIMP Recurrent Neural Network and Dynamics Class. For information about
this class is described below.

Copyright (C) 2020 AMSIMP

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

# -----------------------------------------------------------------------------------------#

# Importing Dependencies
from datetime import timedelta, datetime
import os
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, RepeatVector, TimeDistributed
from tensorflow.keras.layers import Bidirectional
from tensorflow.keras.optimizers import Adam
import tensorflow as tf
import matplotlib.pyplot as plt
from matplotlib import style, ticker, gridspec
import numpy as np
import cartopy.crs as ccrs
from cpython cimport bool
from amsimp.wind cimport Wind
from amsimp.wind import Wind
from astropy.units.quantity import Quantity
import iris
from iris.coords import DimCoord, AuxCoord
from iris.cube import Cube, CubeList
from iris import save
from progress.bar import IncrementalBar
from metpy.calc import smooth_gaussian
from numpy.random import random_sample

# -----------------------------------------------------------------------------------------#

cdef class RNN(Wind):
    """
    AMSIMP Recurrent Neural Network Class - This class is concerned with
    determining the evolution of the state of the atmosphere through
    the utilisation of a recurrent neural network. Weather forecasting
    has traditionally been done by physical models of the atmosphere,
    which are unstable to perturbations, and thus are inaccurate for
    large periods of time. Since machine learning techniques are more
    robust to perturbations, it would be logical to combine a neural network
    with a physical model. Weather forecasting is a sequential data problem,
    therefore, a recurrent neural network is the most suitable option for
    this task. For this particular version of the software, the
    recurrent neural network will be trained solely on temperature and
    relative humidity data. Geopotential height will be added in a future release.
    A seed is set in order to ensure reproducibility.

    Below is a list of the methods included within this class, with a short
    description of their intended purpose. Please see the relevant class methods
    for more information:

    download_historical_data ~ generates a NumPy array of the previous state
    of the atmosphere. The number of days of data which is generated can
    be specified through the utilisation of the parameter, data_size, when
    the class is initialised.
    standardise_data ~ generates a NumPy array which standardises the data
    generated by the download_historical_data method. 
    preprocess_data ~ generates the training dataset for the recurrent
    neural network.
    model_prediction ~ generates a NumPy array of evolution of the
    future state of the atmosphere. This is the prediction generated
    by the recurrent neural network by training on the generated and
    preprocessed training data.
    """

    # Feature Scaling 
    temp_sc = MinMaxScaler(feature_range=(0,1))
    rh_sc = MinMaxScaler(feature_range=(0,1))
    height_sc = MinMaxScaler(feature_range=(0,1))

    # Ensure reproducibility.
    tf.random.set_seed(13)

    def download_historical_data(self):
        """
        Generates a NumPy array of the previous state of the atmosphere.
        The number of days of data which is generated can be specified
        through the utilisation of the parameter, data_size, when the
        class is initialised.

        This data is retrieved from the historical dataset contained
        on the AMSIMP Initial Atmospheric Conditions Repository.
        """
        # Folder containing historical data on GitHub.
        folder = "https://github.com/amsimp/initial-conditions/raw/master/initial_conditions/"

        # Data lists.
        # Temperature.
        cdef list T_list = []

        # Geopotential Height.
        cdef list geo_list = []

        # Relative Humidity.
        cdef list rh_list = []

        # Define variable types.
        cdef np.ndarray T, geo, rh

        # Beginning date of the dataset.
        cdef date = self.date
        date = date + timedelta(days=-self.data_size)

        # Download progresss.
        max_bar = self.data_size * 4
        bar = IncrementalBar('Downloading Historical Data', max=max_bar)

        for i in range(max_bar):
            # Configure the Wind class, so, that it aligns with the
            # paramaters defined by the user.
            config = Wind(
                delta_latitude=self.delta_latitude,
                delta_longitude=self.delta_longitude,
                remove_files=self.remove_files,
                input_date=date,
            )

            # Redefine NumPy arrays.
            # Geopotential Height.
            geo = config.geopotential_height().value
            geo = geo.flatten()
            # Temperature.
            T = config.temperature().value
            T = T.flatten()
            # Relative Humidity.
            rh = config.relative_humidity().value
            rh = rh.flatten()

            # Append to list.
            # Geopotential Height.
            geo_list.append(geo)
            # Temperature.
            T_list.append(T)
            # Relative Humidity.
            rh_list.append(rh)

            # Add six hours to date to get the next dataset.
            date = date + timedelta(hours=+6)

            # Remove download file.
            self.remove_all_files()

            # Increment progress bar.
            bar.next()

        # Convert lists to NumPy arrays.
        # Geopotential Height.
        geopotential_height = np.asarray(geo_list)
        # Temperature.
        temperature = np.asarray(T_list)
        # Relative Humidity.
        relative_humidity = np.asarray(rh_list)

        # Finish bar.
        bar.finish()

        # Output.s
        output = (temperature, relative_humidity, geopotential_height)
        return output        

    def standardise_data(self):
        """
        Generates a NumPy array which standardises the data
        generated by the download_historical_data method. It is important
        to scale features before training a neural network.
        
        Normalisation is a common way of doing this scaling by
        subtracting the mean and dividing by the standard deviation
        of each feature. In order for the most optimal performance,
        the method ``MinMaxScaler" from the library, scikit-learn,
        is utilised within the software.
        """
        # Define atmospheric parameters.
        historical_data = self.download_historical_data()
        temperature = historical_data[0]
        relative_humidity = historical_data[1]
        geopotential_height = historical_data[2]

        # Standardise the data.
        # Temperature.
        temperature = self.temp_sc.fit_transform(temperature)
        # Relative Humidity.
        relative_humidity = self.rh_sc.fit_transform(relative_humidity)
        # Geopotential Height.
        geopotential_height = self.height_sc.fit_transform(geopotential_height)

        # Output.
        output = (temperature, relative_humidity, geopotential_height)
        return output

    def preprocess_data(
        self, dataset, past_history, future_target
    ):
        """
        Generates the training dataset for the recurrent neural network.

        The data set in question is updated every six hours by the National Oceanic
        and Atmospheric Administration. This means for a single day,
        there will be four observations. The goal for the software will be to,
        first predict the relevant atmospheric parameter in seven days time
        given the last thirty days of data and combine this RNN prediction with the
        physical model prediction in an attempt to make a more accurate prediction
        overall. In order to make such predictions, it is necessary to create a
        window of the last 120 (30 x 4) observations to train the model.
        """
        X, y = list(), list()
        for i in range(len(dataset)):
            # Find the end.
            end_ix = i + past_history
            out_end_ix = end_ix + future_target
            
            # Determine if we are beyond the dataset.
            if out_end_ix > len(dataset):
                break
            
            # Gather the input and output components.
            seq_x, seq_y = dataset[i:end_ix, :], dataset[end_ix:out_end_ix, :]

            # Append to list.
            X.append(seq_x)
            y.append(seq_y)

        return np.asarray(X), np.asarray(y)

    def model_prediction(self):
        """
        Generates a NumPy array of evolution of the future state of the atmosphere.

        This is the prediction generated by the recurrent neural network by training
        on the generated and preprocessed training data. Please see the other
        methods within this class for preprocessing information.
        """
        # Dataset.
        dataset = self.standardise_data()

        # Temperature.
        temperature = dataset[0]
        # Relative Humidity.
        relative_humidity = dataset[1]
        # Geopotential Height.
        geopotential_height = dataset[2]

        # The network is shown data from the last 15 days.
        past_history = 20 * 4

        # The network predicts the next 7 days worth of steps.
        future_target = 7 * 4

        # The dataset is preprocessed.
        # Temperature.
        x_temp, y_temp = self.preprocess_data(
            temperature, past_history, future_target
        )
        # Relative Humidity.
        x_rh, y_rh = self.preprocess_data(
            relative_humidity, past_history, future_target
        )
        # Geopotential Height.
        x_height, y_height = self.preprocess_data(
            geopotential_height, past_history, future_target
        )

        # Number of features.
        features = x_temp.shape[2]

        # Create, and train models.
        # Temperature model.
        # Optimiser.
        opt_temp = Adam(lr=1e-6, decay=1e-10, clipvalue=0.6)
        # Create.
        temp_model = Sequential()
        temp_model.add(
            LSTM(
                400, activation='tanh', input_shape=(past_history, features)
            )
        )
        temp_model.add(RepeatVector(future_target))
        temp_model.add(LSTM(400, activation='tanh', return_sequences=True))
        temp_model.add(LSTM(400, activation='relu', return_sequences=True))
        temp_model.add(LSTM(400, activation='relu', return_sequences=True))
        temp_model.add(TimeDistributed(Dense(features)))
        temp_model.compile(optimizer=opt_temp, loss='mse', metrics=['mean_absolute_error'])
        # Train.
        temp_model.fit(
            x_temp, y_temp, epochs=self.epochs, batch_size=20
        )

        # Relative Humidity model.
        # Optimiser.
        opt_rh = Adam(lr=1e-6, decay=1e-10, clipvalue=0.6)
        # Create.
        rh_model = Sequential()
        rh_model.add(
            LSTM(
                400, activation='tanh', input_shape=(past_history, features)
            )
        )
        rh_model.add(RepeatVector(future_target))
        rh_model.add(LSTM(400, activation='tanh', return_sequences=True))
        rh_model.add(LSTM(400, activation='relu', return_sequences=True))
        rh_model.add(LSTM(400, activation='relu', return_sequences=True))
        rh_model.add(TimeDistributed(Dense(features)))
        rh_model.compile(optimizer=opt_rh, loss='mse', metrics=['mean_absolute_error'])
        # Train.
        rh_model.fit(
            x_rh, y_rh, epochs=self.epochs, batch_size=20
        )

        # Geopotential height model.
        # Optimiser.
        opt_height = Adam(lr=1e-6, decay=1e-10, clipvalue=0.6)
        # Create.
        height_model = Sequential()
        height_model.add(
            LSTM(
                400, activation='tanh', input_shape=(past_history, features)
            )
        )
        height_model.add(RepeatVector(future_target))
        height_model.add(LSTM(400, activation='tanh', return_sequences=True))
        height_model.add(LSTM(400, activation='relu', return_sequences=True))
        height_model.add(LSTM(400, activation='relu', return_sequences=True))
        height_model.add(TimeDistributed(Dense(features)))
        height_model.compile(optimizer=opt_height, loss='mse', metrics=['mean_absolute_error'])
        # Train.
        height_model.fit(
            x_height, y_height, epochs=self.epochs, batch_size=20
        )

        # Prediction.
        # Set up inputs.
        predict_temp_input = temperature[-past_history:, :]
        predict_temp_input = predict_temp_input.reshape(
            1, predict_temp_input.shape[0], predict_temp_input.shape[1]
        )
        predict_rh_input = relative_humidity[-past_history:, :]
        predict_rh_input = predict_rh_input.reshape(
            1, predict_rh_input.shape[0], predict_rh_input.shape[1]
        )
        predict_height_input = geopotential_height[-past_history:, :]
        predict_height_input = predict_height_input.reshape(
            1, predict_height_input.shape[0], predict_height_input.shape[1]
        )
        # Make predictions.
        predict_temp = temp_model.predict(predict_temp_input)
        predict_temp = predict_temp[0]
        predict_rh = rh_model.predict(predict_rh_input)
        predict_rh = predict_rh[0]
        predict_height = rh_model.predict(predict_height_input)
        predict_height = predict_height[0]

        # Invert normalisation.
        predict_temp = self.temp_sc.inverse_transform(predict_temp)
        predict_rh = self.rh_sc.inverse_transform(predict_rh)
        predict_height = self.rh_sc.inverse_transform(predict_height)

        # Reshape into 3d arrays.
        # Dimensions.
        len_time = len(predict_temp)
        len_pressure = len(self.pressure_surfaces())
        len_lat = len(self.latitude_lines())
        len_lon = len(self.longitude_lines())
        # Reshape.
        predict_temp = predict_temp.reshape(len_time, len_pressure, len_lat, len_lon)
        predict_rh = predict_rh.reshape(len_time, len_pressure, len_lat, len_lon)
        predict_height = predict_height.reshape(len_time, len_pressure, len_lat, len_lon)

        return predict_temp, predict_rh, predict_height

cdef class Dynamics(RNN):
    """
    AMSIMP Dynamics Class - Also, known as Motus Aeris @ AMSIMP. This class
    generates a simulation of tropospheric and stratsopheric dynamics. 
    Predictions are made by numerically solving the isobaric version of the
    Primitive Equations (they are coupled set of nonlinear PDEs). The initial conditions
    are defined in the class methods of Water, Moist, and Backend. For more information
    on the initial conditions, please see those classes.
    
    Below is a list of the methods included within this class, with a short
    description of their intended purpose. Please see the relevant class methods
    for more information.

    forecast_period ~ generates the period of time over which the forecast will
    be generated for. Please also note that this method also outputs the change in time
    used. This is used in the prognostic equations. 
    simulate ~ generates a simulation of tropospheric and stratsopheric dynamics.
    visualise ~ please explain here.
    """

    def __cinit__(self, int delta_latitude=5, int delta_longitude=5, bool remove_files=False, forecast_length=72, delta_t=2, bool ai=True, data_size=150, epochs=200, input_date=None, bool input_data=False, geo=None, temp=None, rh=None, u=None, v=None):
        """
        The parameter, forecast_length, defines the length of the 
        simulation (defined in hours). Defaults to a value of 72.

        The parameter, delta_t, defines the change with respect to time
        (in minutes) defined in the simulation. Defaults to a value of 2.
        
        For more information, please refer to amsimp.Backend.__cinit__()
        method.
        """
        # Add units to forecast length variable.
        if type(forecast_length) != Quantity:
            forecast_length = forecast_length * self.units.h
        # Add units to delta_t variable.
        if type(delta_t) != Quantity:
            delta_t = delta_t * self.units.min

        # Declare class variables.
        super().__init__(delta_latitude)
        super().__init__(delta_longitude)
        super().__init__(remove_files)
        self.forecast_length = forecast_length
        self.delta_t = delta_t
        self.ai = ai
        super().__init__(input_date)
        super().__init__(input_data)
        super().__init__(geo)
        super().__init__(temp)
        super().__init__(rh)
        super().__init__(u)
        super().__init__(v)
        
        # Ensure self.forecast_length is greater than, or equal to 1.
        if self.forecast_length.value <= 0:
            raise Exception(
                "forecast_length must be a positive number greater than, or equal to 1. The value of forecast_length was: {}".format(
                    self.forecast_length
                )
            )
        
        # Ensure ai is a boolean value.
        if not isinstance(self.ai, bool):
            raise Exception(
                "ai must be a boolean value. The value of ai was: {}".format(
                    self.ai
                )
            )

    cpdef tuple forecast_period(self):
        """
        Generates the period of time over which the forecast will be generated
        for. 
        
        Explain more.
        """
        segments = int((self.forecast_length / self.delta_t).si.value) + 1

        # Define the forecast period.
        forecast_period = np.linspace(
            0, self.forecast_length.value, segments
        ) * self.forecast_length.unit

        # Convert to seconds.
        delta_t = self.delta_t.to(self.units.s)

        return forecast_period, delta_t

    cpdef simulate(self, bool save_file=False):
        """
        Generates a simulation of tropospheric and stratsopheric dynamics.
        Predictions are made by numerically solving the Primitive
        Equations (they are coupled set of nonlinear PDEs). Depending on the
        parameter specifed in the initialisation of the class, a recurrent 
        neural network may be incorpated in the output.
        
        Explain here (Primitive Equations).

        The parameter, save_file, may be utilised to save the output of
        this class. The output will be saved as a NetCDF file. These
        files can be opened by using the Iris library, which can
        be downloaded via Anaconda Cloud.
        """    
        # Ensure save_file is a boolean value.
        if not isinstance(save_file, bool):
            raise Exception(
                "save_file must be a boolean value. The value of save_file was: {}".format(
                    save_file
                )
            )

        # Define variables that do not vary with respect to time.
        cdef lat = self.latitude_lines().value
        cdef np.ndarray latitude = np.radians(lat)
        cdef np.ndarray longitude = np.radians(self.longitude_lines().value)
        cdef np.ndarray pressure = self.pressure_surfaces()
        cdef np.ndarray pressure_3d = self.pressure_surfaces(dim_3d=True)
        cdef time = self.forecast_period()[0]
        
        # The Coriolis parameter at various latitudes of the Earth's surface,
        # under various approximations.
        # No approximation.
        cdef np.ndarray f = self.coriolis_parameter().value / self.units.s
        f = self.make_3dimensional_array(parameter=f, axis=1)

        # Define the change with respect to time.
        cdef delta_t = self.forecast_period()[1]
        cdef delta_2t = delta_t * 2
        cdef delta_halfstep = delta_t / 2
        # Forecast length.
        cdef forecast_length = self.forecast_period()[0][-1].to(self.units.s)
        cdef int t = 0

        # Define initial conditions.
        # Gravitational Acceleration.
        cdef np.ndarray g = self.gravitational_acceleration()
        # Geopotential Height.
        cdef np.ndarray height = self.geopotential_height()
        # Wind.
        cdef tuple wind = self.wind()
        # Zonal Wind.
        cdef np.ndarray u = wind[0]
        cdef np.ndarray u_i = u
        # Meridional Wind.
        cdef np.ndarray v = wind[1]
        cdef np.ndarray v_i = v
        # Vertical Motion.
        cdef np.ndarray omega = self.vertical_motion()
        # Static Stability.
        cdef np.ndarray sigma = self.static_stability()
        # Temperature.
        # Air Temperature.
        cdef np.ndarray T = self.temperature()
        cdef np.ndarray T_i = T
        # Virtual Temperature.
        cdef np.ndarray T_v = self.virtual_temperature()
        # Relative Humidity.
        cdef np.ndarray rh = self.relative_humidity()
        # Mixing Ratio.
        cdef np.ndarray q = self.mixing_ratio()
        cdef np.ndarray q_i = q
        # Precipitable Water.
        cdef np.ndarray pwv = self.precipitable_water()

        # Prediction from Recurrent Neural Network.
        cdef np.ndarray prediction_ai_temp, prediction_ai_height, prediction_ai_rh
        cdef int iterator_ai
        if self.ai:
            prediction_ai = self.model_prediction()
            prediction_ai_height = prediction_ai[2] * self.units.m
            prediction_ai_temp = prediction_ai[0] * self.units.K
            prediction_ai_rh = prediction_ai[1] * self.units.percent
            iterator_ai = 0

        # Define extra variable types.
        # Numy Arrays.
        cdef np.ndarray T_0, T_n, q_0, q_n, u_0, u_n, v_0, v_n, dT_dx, dT_dy, dT_dp
        cdef np.ndarray du_dx, du_dy, du_dp, dv_dx, dv_dy, dv_dp, A, B 
        cdef np.ndarray C, D, E, RHS, dq_dx, dq_dy, dq_dp, e, T_c, sat_vapor_pressure
        cdef np.ndarray geopotential_height, temperature, virtual_temperature
        cdef np.ndarray zonal_wind, meridional_wind, static_stability 
        cdef np.ndarray relative_humidity, mixing_ratio, precipitable_water
        cdef np.ndarray height_new, z2, z1, p_height, Tv, Tv_mean
        # Booleans.
        cdef bool break_loop
        # Ints / Floats.
        cdef int len_p = len(pressure) - 1
        cdef int i
        # Tuples.
        cdef tuple shape, shape_2d

        # Create a bar to determine progress.
        max_bar = len(time)
        bar = IncrementalBar('Progress', max=max_bar)
        # Start progress bar.
        bar.next()

        # Define NumPy array for ouputs.
        shape = (len(time), len(pressure), len(latitude), len(longitude))
        shape_2d = (len(time), len(latitude), len(longitude))
        # Geopotential Height.
        geopotential_height = np.zeros(shape) * height.unit
        geopotential_height[0, :, :, :] = height
        # Temperature.
        # Air Temperature.
        temperature = np.zeros(shape) * T_i.unit
        temperature[0, :, :, :] = T_i 
        # Virtual Temperature.
        virtual_temperature = np.zeros(shape) * T_v.unit
        virtual_temperature[0, :, :, :] = T_v 
        # Geostrophic Wind.
        # Zonal Wind.
        zonal_wind = np.zeros(shape) * u.unit
        zonal_wind[0, :, :, :] = u
        # Meridional Wind.
        meridional_wind = np.zeros(shape) * v.unit
        meridional_wind[0, :, :, :] = v
        # Vertical Motion.
        vertical_motion = np.zeros(shape) * omega.unit
        vertical_motion[0, :, :, :] = omega
        # Static Stability.
        static_stability = np.zeros(shape) * sigma.unit
        static_stability[0, :, :, :] = sigma
        # Relative Humidity.
        relative_humidity = np.zeros(shape) * rh.unit
        relative_humidity[0, :, :, :] = rh
        # Mixing Ratio.
        mixing_ratio = np.zeros(shape) * q_i.unit
        mixing_ratio[0, :, :, :] = q_i
        # Precipitable Water.
        precipitable_water = np.zeros(shape_2d) * pwv.unit
        precipitable_water[0, :, :] = pwv

        cdef int n = 0
        cdef int len_t = 1
        try:
            while t < forecast_length.value:
                # Wind.
                # Zonal Wind.
                if n > 2:
                    u_0 = u
                    u = u_n

                # Meridional Wind.
                if n > 2:
                    v_0 = v
                    v = v_n

                # Temperature.
                if n > 2:
                    T_0 = T
                    T = T_n
                
                # Mixing ratio.
                if n > 2:
                    q_0 = q
                    q = q_n

                # Wind
                # Scalar gradients of geopotential height.
                dz_dx = self.gradient_x(
                    parameter=np.gradient(
                        height, longitude, axis=2
                    )
                )
                dz_dy = self.gradient_y(parameter=height)

                # Zonal Wind.
                # Scalar gradients of wind wind.
                du_dx = self.gradient_x(
                    parameter=np.gradient(
                        u, longitude, axis=2
                    )
                )
                du_dy = self.gradient_y(parameter=u)
                du_dp = self.gradient_p(parameter=u)

                # Determine each term in the zonal momentum equation.
                A = -u * du_dx
                B = -v * du_dy
                C = -omega * du_dp
                D = -g * dz_dx
                E = f * v

                # Sum the RHS terms and multiple by the time step.
                if n == 0:
                    RHS = (A + B + C + D + E) * delta_halfstep
                else:
                    RHS = (A + B + C + D + E) * delta_2t

                if n == 0:
                    u = u_i + RHS
                elif n == 1:
                    u = u_i + RHS
                elif n == 2:
                    u_n = u_i + RHS
                else:
                    u_n[:, 1:-1, 1:-1] = u_0[:, 1:-1, 1:-1] + RHS[:, 1:-1, 1:-1]
                    # Apply Robert-Asselin time filter.
                    u = u + 0.1 * (u_n - 2*u + u_0)

                # Smoothing operator (filter with normal distribution
                # of weights).
                u = smooth_gaussian(
                    scalar_grid=u.value,
                    n=3,
                ).magnitude * u.unit

                # Meridional Wind.
                # Scalar gradients of wind wind.
                dv_dx = self.gradient_x(
                    parameter=np.gradient(
                        v, longitude, axis=2
                    )
                )
                dv_dy = self.gradient_y(parameter=v)
                dv_dp = self.gradient_p(parameter=v)

                # Determine each term in the meridional momentum equation.
                A = -u * dv_dx
                B = -v * dv_dy
                C = -omega * dv_dp
                D = -g * dz_dy
                E = -f * u

                # Sum the RHS terms and multiple by the time step.
                if n == 0:
                    RHS = (A + B + C + D + E) * delta_halfstep
                else:
                    RHS = (A + B + C + D + E) * delta_2t

                if n == 0:
                    v = v_i + RHS
                elif n == 1:
                    v = v_i + RHS
                elif n == 2:
                    v_n = v_i + RHS
                else:
                    v_n[:, 1:-1, 1:-1] = v_0[:, 1:-1, 1:-1] + RHS[:, 1:-1, 1:-1]
                    # Apply Robert-Asselin time filter.
                    v = v + 0.1 * (v_n - 2*v + v_0)

                # Smoothing operator (filter with normal distribution
                # of weights).
                v = smooth_gaussian(
                    scalar_grid=v.value,
                    n=3,
                ).magnitude * v.unit

                # Temperature.
                # Air Temperature.
                # Scalar gradients of temperature.
                dT_dx = self.gradient_x(
                    parameter=np.gradient(
                        T, longitude, axis=2
                    )
                )

                dT_dy = self.gradient_y(parameter=T)
                dT_dp = self.gradient_p(parameter=T)

                # Thermodynamic Equation.
                A = -u * dT_dx
                B = -v * dT_dy
                C = -omega * dT_dp
                D = omega * ((self.R * T) / (pressure_3d * self.c_p))
                
                if n == 0:
                    RHS = (A + B + C + D) * delta_halfstep
                else:
                    RHS = (A + B + C + D) * delta_2t

                if n == 0:
                    T = T_i + RHS
                elif n == 1:
                    T = T_i + RHS
                elif n == 2:
                    T_n = T_i + RHS
                else:
                    T_n[:, 1:-1, 1:-1] = T_0[:, 1:-1, 1:-1] + RHS[:, 1:-1, 1:-1]
                    # Apply Robert-Asselin time filter.
                    T = T + 0.1 * (T_n - 2*T + T_0)
                
                # Smoothing operator (filter with normal distribution
                # of weights).
                T = smooth_gaussian(
                    scalar_grid=T.value,
                    n=3,
                ).magnitude * T.unit

                # Mixing ratio
                # The scalar gradients of the mixing ratio.
                dq_dx = self.gradient_x(
                    parameter=np.gradient(
                        q, longitude, axis=2
                    )
                )
                dq_dy = self.gradient_y(parameter=q)
                dq_dp = self.gradient_p(parameter=q)

                # Advect mixing ratio via wind. Sources and sinks
                # need to be added later!!!!!!
                A = -u * dq_dx
                B = -v * dq_dy
                C = -omega * dq_dp
                
                if n == 0:
                    RHS = (A + B + C) * delta_halfstep
                else:
                    RHS = (A + B + C) * delta_2t

                if n == 0:
                    q = q_i + RHS
                elif n == 1:
                    q =q_i + RHS
                elif n == 2:
                    q_n = q_i + RHS
                else:
                    q_n[:, 1:-1, 1:-1] = q_0[:, 1:-1, 1:-1] + RHS[:, 1:-1, 1:-1]
                    # Apply Robert-Asselin time filter.
                    q = q + 0.1 * (q_n - 2*q + q_0)

                # Smoothing operator (filter with normal distribution
                # of weights).
                q = smooth_gaussian(
                    scalar_grid=q.value,
                    n=3,
                ).magnitude * q.unit

                # Vapor pressure.
                e = pressure_3d * q / (0.622 + q)

                # Convert temperature in Kelvin to degrees centigrade.
                T_c = T.value - 273.15
                # Saturated vapor pressure.
                sat_vapor_pressure = 0.61121 * np.exp(
                    (
                        18.678 - (T_c / 234.5)
                    ) * (T_c / (257.14 + T_c)
                    )
                ) 
                # Add units of measurement.
                sat_vapor_pressure *= self.units.kPa
                sat_vapor_pressure = sat_vapor_pressure.to(self.units.hPa)

                # Relative Humidity.
                rh = (e.value / sat_vapor_pressure.value) * 100
                rh[rh > 100] = 100
                rh[rh < 0] = 0
                rh *= self.units.percent

                # Virtual Temperature.
                T_v = T / (
                    1 - (
                    e / pressure_3d
                    ) * (1 - 0.622)
                )

                # Geopotential Height (Hydrostatic Balance).
                z2 = height[-1]
                Tv = T_v[::-1, :, :]
                p_height = pressure[::-1]
                height_new = np.zeros(Tv.value.shape) * height.unit
                height_new[0, :, :] = z2

                for i in range(len_p):
                    Tv_mean = (Tv[i+1, :, :] + Tv[i, :, :]) / 2
                    z1 = z2 - (
                        (
                            (self.R * Tv_mean) / self.g
                        ) * np.log(p_height[i+1] / p_height[i])
                    )
                    height_new[i+1, :, :] = z1
                    z2 = z1

                height = height_new[::-1, :, :]

                # Recurrent Neural Network.
                if self.ai:
                    # Apply predictions every six hours.
                    if t != 0 and t % 21600 == 0:
                        # Geopotential Height.
                        height = (height + prediction_ai_height[iterator_ai]) / 2
                        # Temperature. 
                        T = (T + prediction_ai_temp[iterator_ai]) / 2
                        # Relative Humidity.
                        rh = (rh + prediction_ai_rh[iterator_ai]) / 2
                        # Iterator.
                        iterator_ai += 1
                
                # Configure the Wind class, so, that it aligns with the
                # paramaters defined by the user.
                break_loop = False
                while not break_loop:
                    try:
                        config = Wind(
                            delta_latitude=self.delta_latitude,
                            delta_longitude=self.delta_longitude,
                            remove_files=self.remove_files,
                            input_data=True, 
                            geo=height, 
                            temp=T, 
                            rh=rh,
                            u=u,
                            v=v 
                        )
                        break_loop = True
                    except:
                        pass

                # Static Stability.
                sigma = config.static_stability()

                # Vertical Motion.
                omega = config.vertical_motion()

                # Precipitable Water.
                pwv = config.precipitable_water()

                # Gravitational Acceleration.
                g = config.gravitational_acceleration()

                # Add predictions to NumPy arrays.
                if n > 1:
                    # Geopotential Height.
                    geopotential_height[len_t, :, :, :] = height
                    # Geostrophic Wind.
                    # Zonal Wind.
                    zonal_wind[len_t, :, :, :] = u
                    # Meridional Wind.
                    meridional_wind[len_t, :, :, :] = v
                    # Static Stability
                    static_stability[len_t, :, :, :] = sigma
                    # Temperature.
                    # Air Temperature.
                    temperature[len_t, :, :, :] = T
                    # Virtual Temperature.
                    virtual_temperature[len_t, :, :, :] = T_v
                    # Relative Humidity.
                    relative_humidity[len_t, :, :, :] = rh
                    # Mixing Ratio.
                    mixing_ratio[len_t, :, :, :] = q
                    # Precipitable Water.
                    precipitable_water[len_t, :, :] = pwv

                    # Add time step.
                    t += delta_t.value
                    len_t += 1
                    bar.next()
                
                n += 1
        except KeyboardInterrupt:
            pass

        # Finish progress bar.
        bar.finish()

        # Define the coordinates for the cube. 
        # Latitude.
        lat = DimCoord(
            self.latitude_lines(),
            standard_name='latitude',
            units='degrees'
        )
        # Longitude
        lon = DimCoord(
            self.longitude_lines(),
            standard_name='longitude', 
            units='degrees'
        )
        # Pressure Surfaces.
        p = DimCoord(
            pressure,
            long_name='pressure', 
            units='hPa'
        )
        # Time.
        forecast_period = DimCoord(
            time,
            standard_name='forecast_period', 
            units='hours'
        )
        # Forecast reference time.
        ref_time = AuxCoord(
            self.date.strftime("%Y-%m-%d %H:%M:%S"),
            standard_name='forecast_reference_time'
        )

        # Cubes
        # Geopotential Height Cube.
        height_cube = Cube(geopotential_height,
            standard_name='geopotential_height',
            units='m',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        height_cube.add_aux_coord(ref_time)
        # Geostrophic Wind Cubes.
        # Zonal Wind Cube.
        u_cube = Cube(zonal_wind,
            standard_name='x_wind',
            units='m s-1',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        u_cube.add_aux_coord(ref_time)
        # Meridional Wind Cube.
        v_cube = Cube(meridional_wind,
            standard_name='y_wind',
            units='m s-1',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        v_cube.add_aux_coord(ref_time)
        # Static Stability.
        sigma_cube = Cube(static_stability,
            long_name='static_stability',
            units='J hPa-2 kg-1',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        sigma_cube.add_aux_coord(ref_time)
        # Temperature.
        # Air Temperature.
        T_cube = Cube(temperature,
            standard_name='air_temperature',
            units='K',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        T_cube.add_aux_coord(ref_time)
        # Virtual Temperature.
        Tv_cube = Cube(virtual_temperature,
            standard_name='virtual_temperature',
            units='K',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        Tv_cube.add_aux_coord(ref_time)
        # Relative Humidity.
        rh_cube = Cube(relative_humidity,
            standard_name='relative_humidity',
            units='%',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        rh_cube.add_aux_coord(ref_time)
        # Mixing Ratio.
        q_cube = Cube(mixing_ratio,
            long_name='mixing_ratio',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        q_cube.add_aux_coord(ref_time)
        # Precipitable Water.
        pwv_cube = Cube(precipitable_water,
            long_name='precipitable_water',
            units='mm',
            dim_coords_and_dims=[
                (forecast_period, 0), (lat, 1), (lon, 2)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        pwv_cube.add_aux_coord(ref_time)

        # Create Cube list of output parameters.
        output = CubeList([
            height_cube,
            u_cube,
            v_cube,
            sigma_cube,
            T_cube,
            Tv_cube,
            rh_cube,
            q_cube,
            pwv_cube
        ])

        # If specified, save the forecast in the file format, .nc.
        if save_file:
            # Establish the file name.
            filename = 'motusaeris_amsimp_' + str(self.date.year)
            filename += str(self.date.month) + str(self.date.day)
            filename += str(self.date.hour) + '.nc'

            # Save.
            save(output, filename)

        return output

    def visualise(self, data=None):
        """
        Explain here.

        Need to fix.
        """
        if data == None:
            raise Exception("The dataset for simulation must be defined.")

        # Define the forecast period.
        time = data

        # Style of graph.
        style.use("fivethirtyeight")

        # Define layout.
        gs = gridspec.GridSpec(2, 2)
        fig = plt.figure(figsize=(18.5, 7.5))
        fig.subplots_adjust(hspace=0.340, bottom=0.105, top=0.905)
        plt.ion()

        # Temperature
        indx_long = (np.abs(self.longitude_lines().value - 0)).argmin()
        ax1 = plt.subplot(gs[0, 0])
        forecast_temp = data
        # Geopotential Height
        ax2 = plt.subplot(gs[1, 0], projection=ccrs.EckertIII())
        forecast_height = data
        # Precipitable Water
        ax3 = plt.subplot(gs[0, 1], projection=ccrs.EckertIII())
        forecast_Pwv = data
        # Pressure Thickness (1000hPa - 500hPa).
        ax4 = plt.subplot(gs[1, 1], projection=ccrs.EckertIII())
        forecast_pthickness = data

        # Troposphere - Stratosphere Boundary Line
        trop_strat_line = self.troposphere_boundaryline().value
        trop_strat_line = np.mean(trop_strat_line) + np.zeros(
            len(trop_strat_line)
        )

        t = 0
        while t < len(time):
            # Defines the axes.
            # For the temperature contour plot.
            latitude, pressure = np.meshgrid(
                self.latitude_lines().value, self.pressure_surfaces().value
            )
            # For the geopotential height, precipitable water, and pressure 
            # thickness countour plot
            lat, long = np.meshgrid(
                self.latitude_lines().value, self.longitude_lines().value
            )
            
            # Temperature contour plot.
            # Temperature data.
            temperature = forecast_temp[t]
            temperature = temperature[:, :, indx_long]

            # Contour plotting.
            cmap1 = plt.get_cmap("hot")
            min1 = np.min(forecast_temp[0])
            max1 = np.max(forecast_temp[0])
            level1 = np.linspace(min1, max1, 21)
            temp = ax1.contourf(
                latitude, pressure, temperature, cmap=cmap1, levels=level1
            )

            # Checks for a colorbar.
            if t == 0:
                cb1 = fig.colorbar(temp, ax=ax1)
                tick_locator = ticker.MaxNLocator(nbins=10)
                cb1.locator = tick_locator
                cb1.update_ticks()
                cb1.set_label("Temperature (K)")

            # Add SALT to the graph.
            ax1.set_xlabel("Latitude ($\phi$)")
            ax1.set_ylabel("Pressure (hPa)")
            ax1.set_yscale('log')
            ax1.set_title("Temperature")

            # Geopotential height contour.
            # Geopotential height data.
            height = forecast_height[t]
            height = height[0, :, :]
            height = np.transpose(height)

            # EckertIII projection details.
            ax2.set_global()
            ax2.coastlines()
            ax2.gridlines()

            # Contourf plotting.
            height_sealevel = np.asarray(forecast_height)
            height_sealevel = height_sealevel[:, 0, :, :]
            cmap2 = plt.get_cmap("jet")
            min2 = np.min(height_sealevel)
            max2 = np.max(height_sealevel)
            level2 = np.linspace(min2, max2, 21)
            geopotential_height = ax2.contourf(
                long,
                lat,
                height,
                cmap=cmap2,
                levels=level2,
                transform=ccrs.PlateCarree(),
            )

            # Checks for a colorbar.
            if t == 0:
                cb2 = fig.colorbar(geopotential_height, ax=ax2)
                tick_locator = ticker.MaxNLocator(nbins=10)
                cb2.locator = tick_locator
                cb2.update_ticks()
                cb2.set_label("Pressure (hPa)")

            # Add SALT to the graph.
            ax2.set_xlabel("Longitude ($\lambda$)")
            ax2.set_ylabel("Latitude ($\phi$)")
            ax2.set_title(
                "Geopotential Height (Pressure = " 
                + str(self.pressure_surfaces()[0])
                + ")"
            )

            # Precipitable water contour.
            # Precipitable water data.
            precipitable_water = forecast_Pwv[t, :, :]
            precipitable_water = np.transpose(precipitable_water)
            print(precipitable_water.ndim)

            # EckertIII projection details.
            ax3.set_global()
            ax3.coastlines()
            ax3.gridlines()

            # Contourf plotting.
            cmap3 = plt.get_cmap("seismic")
            min3 = np.min(forecast_Pwv[0])
            max3 = np.max(forecast_Pwv[0])
            level3 = np.linspace(min3, max3, 21)
            precipitable_watervapour = ax3.contourf(
                long,
                lat,
                precipitable_water,
                cmap=cmap3,
                levels=level3,
                transform=ccrs.PlateCarree(),
            )

            # Checks for a colorbar.
            if t == 0:
                cb3 = fig.colorbar(precipitable_watervapour, ax=ax3)
                tick_locator = ticker.MaxNLocator(nbins=10)
                cb3.locator = tick_locator
                cb3.update_ticks()
                cb3.set_label("Precipitable Water (mm)")

            # Add SALT to the graph.
            ax3.set_xlabel("Longitude ($\lambda$)")
            ax3.set_ylabel("Latitude ($\phi$)")
            ax3.set_title("Precipitable Water")

            # Pressure thickness scatter plot.
            # Pressure thickness data.
            pressure_thickness = forecast_pthickness[t]
            pressure_thickness = np.transpose(pressure_thickness)

            # EckertIII projection details.
            ax4.set_global()
            ax4.coastlines()
            ax4.gridlines()

            # Contourf plotting.
            min4 = np.min(forecast_pthickness)
            max4 = np.max(forecast_pthickness)
            level4 = np.linspace(min4, max4, 21)
            pressure_h = ax4.contourf(
                long,
                lat,
                pressure_thickness,
                transform=ccrs.PlateCarree(),
                levels=level4,
            )

            # Index of the rain / snow line
            indx_snowline = (np.abs(level4 - 5400)).argmin()
            pressure_h.collections[indx_snowline].set_color('black')
            pressure_h.collections[indx_snowline].set_linewidth(1) 

            # Add SALT.
            ax4.set_xlabel("Latitude ($\phi$)")
            ax4.set_ylabel("Longitude ($\lambda$)")
            ax4.set_title("Thickness (1000 hPa - 500 hPa)")

            # Checks for a colorbar.
            if t == 0:
                cb4 = fig.colorbar(pressure_h, ax=ax4)
                tick_locator = ticker.MaxNLocator(nbins=10)
                cb4.locator = tick_locator
                cb4.update_ticks()
                cb4.set_label("Pressure Thickness (m)")

            # Plots the average boundary line on two contourfs.
            # Temperature contourf.
            ax1.plot(
                latitude[1],
                trop_strat_line,
                color="black",
                linestyle="dashed",
                label="Troposphere - Stratosphere Boundary Line",
            )
            ax1.legend(loc=0)

            fig.suptitle(
                "Motus Aeris @ AMSIMP"
            )

            # Displaying simualtion.
            plt.show()
            plt.pause(0.01)
            if t < (len(time) - 1):
                ax1.clear()
                ax2.clear()
                ax3.clear()
                ax4.clear()
            else:
                plt.pause(10)

            note = (
                "Note: Rain / Snow Line is marked on the Pressure Thickness" 
                + " contour plot by the black line (5,400 m)."
            )

            # Footnote
            plt.figtext(
                0.99,
                0.01,
                note,
                horizontalalignment="right",
                fontsize=10,
            )

            t += 1
