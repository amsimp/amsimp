#cython: linetrace=True
#distutils: define_macros=CYTHON_TRACE_NOGIL=1
#cython: language_level=3
"""
AMSIMP Recurrent Neural Network and Dynamics Class. For information about this class is described below.
"""

# -----------------------------------------------------------------------------------------#

# Importing Dependencies
from datetime import timedelta, datetime
import os
import wget
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import RepeatVector
from tensorflow.keras.layers import TimeDistributed
from tensorflow.keras.layers import Bidirectional
from tensorflow.keras.optimizers import Adam
import tensorflow as tf
import matplotlib.pyplot as plt
from matplotlib import style
import matplotlib.gridspec as gridspec
from matplotlib import ticker
import numpy as np
import cartopy.crs as ccrs
from cpython cimport bool
from amsimp.wind cimport Wind
from amsimp.wind import Wind
from astropy.units.quantity import Quantity
import iris
from iris.coords import DimCoord
from iris.coords import AuxCoord
from iris.cube import Cube
from iris.cube import CubeList
from iris import save
from progress.bar import IncrementalBar
from metpy.calc import smooth_gaussian
from numpy.random import random_sample

# -----------------------------------------------------------------------------------------#

cdef class RNN(Wind):
    """
    AMSIMP Recurrent Neural Network Class - This class is concerned with
    determining the evolution of the state of the atmosphere through
    the utilisation of a recurrent neural network. Weather forecasting
    has traditionally been done by physical models of the atmosphere,
    which are unstable to perturbations, and thus are inaccurate for
    large periods of time. Since machine learning techniques are more
    robust to perturbations, it would be logical to combine a neural network
    with a physical model. Weather forecasting is a sequential data problem,
    therefore, a recurrent neural network is the most suitable option for
    this task. For this particular version of the software, the
    recurrent neural network will be trained solely on temperature and
    relative humidity data. Geopotential height will be added in a future release.
    A seed is set in order to ensure reproducibility.

    Below is a list of the methods included within this class, with a short
    description of their intended purpose. Please see the relevant class methods
    for more information:

    download_historical_data ~ generates a NumPy array of the previous state
    of the atmosphere. The number of days of data which is generated can
    be specified through the utilisation of the parameter, data_size, when
    the class is initialised.
    standardise_data ~ generates a NumPy array which standardises the data
    generated by the download_historical_data method. 
    preprocess_data ~ generates the training dataset for the recurrent
    neural network.
    model_prediction ~ generates a NumPy array of evolution of the
    future state of the atmosphere. This is the prediction generated
    by the recurrent neural network by training on the generated and
    preprocessed training data.
    """

    # Feature Scaling 
    temp_sc = MinMaxScaler(feature_range=(0,1))
    rh_sc = MinMaxScaler(feature_range=(0,1))
    height_sc = MinMaxScaler(feature_range=(0,1))

    # Ensure reproducibility.
    tf.random.set_seed(13)

    def download_historical_data(self):
        """
        Generates a NumPy array of the previous state of the atmosphere.
        The number of days of data which is generated can be specified
        through the utilisation of the parameter, data_size, when the
        class is initialised.

        This data is retrieved from the historical dataset contained
        on the AMSIMP Initial Atmospheric Conditions Repository.
        """
        # Folder containing historical data on GitHub.
        folder = "https://github.com/amsimp/initial-conditions/raw/master/initial_conditions/"

        # Data lists.
        # Temperature.
        cdef list T_list = []

        # Geopotential Height.
        cdef list geo_list = []

        # Relative Humidity.
        cdef list rh_list = []

        # Define variable types.
        cdef np.ndarray T, geo, rh

        # Beginning date of the dataset.
        cdef date = self.date
        date = date + timedelta(days=-self.data_size)

        # Download progresss.
        max_bar = self.data_size * 4
        bar = IncrementalBar('Downloading Historical Data', max=max_bar)

        for i in range(max_bar):
            # Define the date in terms of integers.
            day = date.day
            month = date.month
            year = date.year
            hour = date.hour

            # Adds zero before single digit numbers.
            if day < 10:
                day = "0" + str(day)

            if month < 10:
                month =  "0" + str(month)

            if hour < 10:
                hour = "0" + str(hour)

            # Converts integers to strings.
            day = str(day)
            month = str(month)
            year = str(year)
            hour = str(hour)

            # File url.
            file_url = folder+year+"/"+month+"/"+day+"/"+hour+"/"
            file_url += "initial_conditions.nc"

            # Download file.
            download = wget.download(file_url, bar=None)

            # Load file.
            data = iris.load(download)

            # Convert data to NumPy arrays
            # Temperature.
            T = np.asarray(data[0].data)
            # Geopotential Height.
            geo = np.asarray(data[1].data)
            # Relative Humidity.
            rh = np.asarray(data[2].data)

            # Configure the Wind class, so, that it aligns with the
            # paramaters defined by the user.
            # Check if date is before the 15th of May, as data before
            # this point do not have wind data.
            before_date = datetime(2020, 5, 15, 0)
            if self.date > before_date:
                # Zonal Wind.
                u = np.asarray(data[3].data)
                # Meridional Wind.
                v = np.asarray(data[4].data)
            else:
                #
                geostrophic_wind = self.geostrophic_wind()
                # Zonal Wind.
                u = geostrophic_wind[0]
                # Meridional Wind.
                v = geostrophic_wind[1]

            config = Wind(
                delta_latitude=self.delta_latitude,
                delta_longitude=self.delta_longitude,
                remove_files=self.remove_files,
                input_data=True, 
                geo=geo, 
                temp=T, 
                rh=rh,
                u=u,
                v=v 
            )

            # Redefine NumPy arrays.
            # Geopotential Height.
            geo = config.geopotential_height().value
            geo = geo.flatten()
            # Temperature.
            T = config.temperature().value
            T = T.flatten()
            # Relative Humidity.
            rh = config.relative_humidity().value
            rh = rh.flatten()

            # Append to list.
            # Geopotential Height.
            geo_list.append(geo)
            # Temperature.
            T_list.append(T)
            # Relative Humidity.
            rh_list.append(rh)

            # Add six hours to date to get the next dataset.
            date = date + timedelta(hours=+6)

            # Remove download file.
            os.remove(download)

            # Increment progress bar.
            bar.next()

        # Convert lists to NumPy arrays.
        # Geopotential Height.
        geopotential_height = np.asarray(geo_list)
        # Temperature.
        temperature = np.asarray(T_list)
        # Relative Humidity.
        relative_humidity = np.asarray(rh_list)

        # Finish bar.
        bar.finish()

        # Output.s
        output = (temperature, relative_humidity, geopotential_height)
        return output        

    def standardise_data(self):
        """
        Generates a NumPy array which standardises the data
        generated by the download_historical_data method. It is important
        to scale features before training a neural network.
        
        Normalisation is a common way of doing this scaling by
        subtracting the mean and dividing by the standard deviation
        of each feature. In order for the most optimal performance,
        the method ``MinMaxScaler" from the library, scikit-learn,
        is utilised within the software.
        """
        # Define atmospheric parameters.
        historical_data = self.download_historical_data()
        temperature = historical_data[0]
        relative_humidity = historical_data[1]
        geopotential_height = historical_data[2]

        # Standardise the data.
        # Temperature.
        temperature = self.temp_sc.fit_transform(temperature)
        # Relative Humidity.
        relative_humidity = self.rh_sc.fit_transform(relative_humidity)
        # Geopotential Height.
        geopotential_height = self.height_sc.fit_transform(geopotential_height)

        # Output.
        output = (temperature, relative_humidity, geopotential_height)
        return output

    def preprocess_data(
        self, dataset, past_history, future_target
    ):
        """
        Generates the training dataset for the recurrent neural network.

        The data set in question is updated every six hours by the National Oceanic
        and Atmospheric Administration. This means for a single day,
        there will be four observations. The goal for the software will be to,
        first predict the relevant atmospheric parameter in seven days time
        given the last thirty days of data and combine this RNN prediction with the
        physical model prediction in an attempt to make a more accurate prediction
        overall. In order to make such predictions, it is necessary to create a
        window of the last 120 (30 x 4) observations to train the model.
        """
        X, y = list(), list()
        for i in range(len(dataset)):
            # Find the end.
            end_ix = i + past_history
            out_end_ix = end_ix + future_target
            
            # Determine if we are beyond the dataset.
            if out_end_ix > len(dataset):
                break
            
            # Gather the input and output components.
            seq_x, seq_y = dataset[i:end_ix, :], dataset[end_ix:out_end_ix, :]

            # Append to list.
            X.append(seq_x)
            y.append(seq_y)

        return np.asarray(X), np.asarray(y)

    def model_prediction(self):
        """
        Generates a NumPy array of evolution of the future state of the atmosphere.

        This is the prediction generated by the recurrent neural network by training
        on the generated and preprocessed training data. Please see the other
        methods within this class for preprocessing information.
        """
        # Dataset.
        dataset = self.standardise_data()

        # Temperature.
        temperature = dataset[0]
        # Relative Humidity.
        relative_humidity = dataset[1]
        # Geopotential Height.
        geopotential_height = dataset[2]

        # The network is shown data from the last 15 days.
        past_history = 20 * 4

        # The network predicts the next 7 days worth of steps.
        future_target = 7 * 4

        # The dataset is preprocessed.
        # Temperature.
        x_temp, y_temp = self.preprocess_data(
            temperature, past_history, future_target
        )
        # Relative Humidity.
        x_rh, y_rh = self.preprocess_data(
            relative_humidity, past_history, future_target
        )
        # Geopotential Height.
        x_height, y_height = self.preprocess_data(
            geopotential_height, past_history, future_target
        )

        # Number of features.
        features = x_temp.shape[2]

        # Create, and train models.
        # Temperature model.
        # Optimiser.
        opt_temp = Adam(lr=1e-6, decay=1e-10, clipvalue=0.6)
        # Create.
        temp_model = Sequential()
        temp_model.add(
            LSTM(
                400, activation='tanh', input_shape=(past_history, features)
            )
        )
        temp_model.add(RepeatVector(future_target))
        temp_model.add(LSTM(400, activation='tanh', return_sequences=True))
        temp_model.add(LSTM(400, activation='relu', return_sequences=True))
        temp_model.add(LSTM(400, activation='relu', return_sequences=True))
        temp_model.add(TimeDistributed(Dense(features)))
        temp_model.compile(optimizer=opt_temp, loss='mse', metrics=['mean_absolute_error'])
        # Train.
        temp_model.fit(
            x_temp, y_temp, epochs=self.epochs, batch_size=20
        )

        # Relative Humidity model.
        # Optimiser.
        opt_rh = Adam(lr=1e-6, decay=1e-10, clipvalue=0.6)
        # Create.
        rh_model = Sequential()
        rh_model.add(
            LSTM(
                400, activation='tanh', input_shape=(past_history, features)
            )
        )
        rh_model.add(RepeatVector(future_target))
        rh_model.add(LSTM(400, activation='tanh', return_sequences=True))
        rh_model.add(LSTM(400, activation='relu', return_sequences=True))
        rh_model.add(LSTM(400, activation='relu', return_sequences=True))
        rh_model.add(TimeDistributed(Dense(features)))
        rh_model.compile(optimizer=opt_rh, loss='mse', metrics=['mean_absolute_error'])
        # Train.
        rh_model.fit(
            x_rh, y_rh, epochs=self.epochs, batch_size=20
        )

        # Geopotential height model.
        # Optimiser.
        opt_height = Adam(lr=1e-6, decay=1e-10, clipvalue=0.6)
        # Create.
        height_model = Sequential()
        height_model.add(
            LSTM(
                400, activation='tanh', input_shape=(past_history, features)
            )
        )
        height_model.add(RepeatVector(future_target))
        height_model.add(LSTM(400, activation='tanh', return_sequences=True))
        height_model.add(LSTM(400, activation='relu', return_sequences=True))
        height_model.add(LSTM(400, activation='relu', return_sequences=True))
        height_model.add(TimeDistributed(Dense(features)))
        height_model.compile(optimizer=opt_height, loss='mse', metrics=['mean_absolute_error'])
        # Train.
        height_model.fit(
            x_height, y_height, epochs=self.epochs, batch_size=20
        )

        # Prediction.
        # Set up inputs.
        predict_temp_input = temperature[-past_history:, :]
        predict_temp_input = predict_temp_input.reshape(
            1, predict_temp_input.shape[0], predict_temp_input.shape[1]
        )
        predict_rh_input = relative_humidity[-past_history:, :]
        predict_rh_input = predict_rh_input.reshape(
            1, predict_rh_input.shape[0], predict_rh_input.shape[1]
        )
        predict_height_input = geopotential_height[-past_history:, :]
        predict_height_input = predict_height_input.reshape(
            1, predict_height_input.shape[0], predict_height_input.shape[1]
        )
        # Make predictions.
        predict_temp = temp_model.predict(predict_temp_input)
        predict_temp = predict_temp[0]
        predict_rh = rh_model.predict(predict_rh_input)
        predict_rh = predict_rh[0]
        predict_height = rh_model.predict(predict_height_input)
        predict_height = predict_height[0]

        # Invert normalisation.
        predict_temp = self.temp_sc.inverse_transform(predict_temp)
        predict_rh = self.rh_sc.inverse_transform(predict_rh)
        predict_height = self.rh_sc.inverse_transform(predict_height)

        # Reshape into 3d arrays.
        # Dimensions.
        len_time = len(predict_temp)
        len_pressure = len(self.pressure_surfaces())
        len_lat = len(self.latitude_lines())
        len_lon = len(self.longitude_lines())
        # Reshape.
        predict_temp = predict_temp.reshape(len_time, len_pressure, len_lat, len_lon)
        predict_rh = predict_rh.reshape(len_time, len_pressure, len_lat, len_lon)
        predict_height = predict_height.reshape(len_time, len_pressure, len_lat, len_lon)

        return predict_temp, predict_rh, predict_height

cdef class Dynamics(RNN):
    """
    AMSIMP Dynamics Class - Also, known as Motus Aeris @ AMSIMP. This class
    generates a simulation of tropospheric and stratsopheric dynamics on a
    synoptic scale. Predictions are made by numerically solving the Height
    Tendency and Therodyamic Equations (they are PDEs). An Ensemble Prediction
    System (EPS) is also utilised within the software. An EPSs are numerical weather
    prediction systems that allow for the estimation of uncertainty in a weather
    forecast, as well as, providing a better prediction for the future state
    of the atmosphere. Instead of running a atmospheric dynamical simulation
    once (this would be regarded as deterministic), the simulation is run many
    different time with slightly different initial conditions. The initial conditions
    are defined in the class methods of Water, Moist, and Backend. For more information
    on the initial conditions, please see those classes. Due to the high computational
    resources required to run these simulations, they are often run at half the
    resolution of an equivalent deterministic simulation. The ensemble prediction
    system has a control simulation that doesn't have any perturbations to the initial
    conditions.
    
    Below is a list of the methods included within this class, with a short
    description of their intended purpose. Please see the relevant class methods
    for more information.

    forecast_period ~ generates the period of time over which the forecast will
    be generated for. Please also note that this method also outputs the change in time
    used. This is used in the prognostic equations. 
    atmospheric_prognostic_method ~ generates a simulation of tropospheric and stratsopheric
    dynamics on a synoptic scale.
    """

    def __cinit__(self, int delta_latitude=5, int delta_longitude=5, bool remove_files=False, forecast_length=72, bool ai=True, data_size=150, epochs=200, input_date=None, bool input_data=False, geo=None, temp=None, rh=None, u=None, v=None):
        """
        The parameter, forecast_length, defines the length of the forecast
        (in hours) generated in the simulation. This value must be greater
        than 0, and less than 168 in order to ensure that the simulation
        methods function correctly. Defaults to a value of 72.
        
        For more information, please refer to amsimp.Backend.__cinit__()
        method.
        """
        # Add units to forecast length variable.
        if type(forecast_length) != Quantity:
            forecast_length = forecast_length * self.units.h

        # Declare class variables.
        super().__init__(delta_latitude)
        super().__init__(delta_longitude)
        super().__init__(remove_files)
        self.forecast_length = forecast_length
        self.ai = ai
        super().__init__(input_date)
        super().__init__(input_data)
        super().__init__(geo)
        super().__init__(temp)
        super().__init__(rh)
        super().__init__(u)
        super().__init__(v)

        # Ensure self.forecast_length is between 0 and 168.
        if self.forecast_length.value > 168 or self.forecast_length.value <= 0:
            raise Exception(
                "forecast_length must be a positive integer between 1 and 168. The value of forecast_length was: {}".format(
                    self.forecast_length
                )
            )
        
        # Ensure ai is a boolean value.
        if not isinstance(self.ai, bool):
            raise Exception(
                "ai must be a boolean value. The value of ai was: {}".format(
                    self.ai
                )
            )

    def forecast_period(self):
        """
        Generates the period of time over which the forecast will be generated
        for. 
        
        Please also note that this method also outputs the change in time
        used. This is used in the prognostic equations defined in the method
        atmospheric_prognostic_method.
        """
        forecast_length = int(self.forecast_length.value)

        # Define the forecast period.
        forecast_period = np.linspace(
            0, forecast_length, (forecast_length * 30) + 1
        ) * self.forecast_length.unit

        # Change in time (delta t) utilised to get a numerical solution to the
        # partial derivative equations.
        delta_t = (1/30) * self.units.hr
        delta_t = delta_t.to(self.units.s)

        return forecast_period, delta_t

    cpdef motus_aeris(self, bool save_file=False, p1=1000, p2=500):
        """
        Generates a simulation of tropospheric and stratsopheric dynamics on a
        synoptic scale. Predictions are made by numerically solving the Height
        Tendency and Therodyamic Equations (they are PDEs). Depending on the
        parameter specifed in the initialisation of the class, a recurrent 
        neural network may be incorpated in the output. These equation are
        from the quasi-geostrophic theory.
        
        The basic idea of quasi-geostrophic theory is that it reveals how
        hydrostatic balance and geostrophic balance constrain and simply
        atmospheric dynamics, but, in a realistic manner. It provides
        a framework by which an understanding of, and an ability to
        diagnose, the evolution of a three dimensional synoptic-scale
        weather system. It achieves this by providing insights into
        how mass fields and momentum fields interact to create vertical
        circulations that result in realistic synoptic-scale weather
        patterns.

        The parameter, save_file, may be utilised to save the output of
        this class. The output will be saved as a NetCDF file. These
        files can be opened by using the Iris library, which can
        be downloaded via Anaconda Cloud.
        """
        # Ensure p1 is greater than p2.
        if p1 < p2:
            raise Exception("Please note that p1 must be greater than p2.")
        
        # Ensure save_file is a boolean value.
        if not isinstance(save_file, bool):
            raise Exception(
                "save_file must be a boolean value. The value of save_file was: {}".format(
                    save_file
                )
            )

        # Define variables that do not vary with respect to time.
        cdef lat = self.latitude_lines().value
        cdef np.ndarray latitude = np.radians(lat)
        cdef np.ndarray longitude = np.radians(self.longitude_lines().value)
        cdef np.ndarray pressure = self.pressure_surfaces()
        cdef np.ndarray pressure_3d = self.pressure_surfaces(dim_3d=True)
        cdef time = self.forecast_period()[0]
        
        # The Coriolis parameter at various latitudes of the Earth's surface,
        # under various approximations.
        # No approximation.
        cdef np.ndarray f = self.coriolis_parameter().value / self.units.s
        f = self.make_3dimensional_array(parameter=f, axis=1)
        # beta plane.
        cdef np.ndarray f_beta = self.beta_plane().value / self.units.s
        f_beta = self.make_3dimensional_array(parameter=f_beta, axis=1)
        # f-plane.
        cdef np.ndarray f_0 = self.coriolis_parameter().value / self.units.s
        f_0 = self.make_3dimensional_array(parameter=f_0, axis=1)

        # Define the change with respect to time.
        cdef delta_t = self.forecast_period()[1]
        cdef delta_2t = delta_t * 2
        cdef delta_halfstep = delta_t / 2
        # Forecast length.
        cdef forecast_length = self.forecast_period()[0][-1].to(self.units.s)
        cdef int t = 0

        # Define initial conditions.
        # Gravitational Acceleration.
        cdef np.ndarray g = self.gravitational_acceleration()
        # Geopotential Height.
        cdef np.ndarray height = self.geopotential_height()
        # Geopotential.
        cdef np.ndarray geo = height * g
        cdef np.ndarray geo_i = geo
        # Geostrophic Wind.
        cdef tuple geostrophic_wind = self.geostrophic_wind()
        # Zonal Wind.
        cdef np.ndarray u_g = geostrophic_wind[0]
        # Meridional Wind.
        cdef np.ndarray v_g = geostrophic_wind[1]
        # Non-Geostrophic Wind.
        cdef tuple nongeostrophic_wind = self.wind()
        # Zonal Wind.
        cdef np.ndarray u = nongeostrophic_wind[0]
        cdef np.ndarray u_i = u
        # Meridional Wind.
        cdef np.ndarray v = nongeostrophic_wind[1]
        cdef np.ndarray v_i = v
        # Vertical Motion.
        cdef np.ndarray omega = self.vertical_motion()
        # Static Stability.
        cdef np.ndarray sigma = self.static_stability()
        # Temperature.
        # Air Temperature.
        cdef np.ndarray T = self.temperature()
        cdef np.ndarray T_i = T
        # Virtual Temperature.
        cdef np.ndarray T_v = self.virtual_temperature()
        # Relative Humidity.
        cdef np.ndarray rh = self.relative_humidity()
        # Mixing Ratio.
        cdef np.ndarray q = self.mixing_ratio()
        cdef np.ndarray q_i = q
        # Thickness.
        cdef np.ndarray thickness = self.pressure_thickness(p1=p1, p2=p2)
        # Precipitable Water.
        cdef np.ndarray pwv = self.precipitable_water()

        # Index of pressure surfaces.
        cdef int indx_p1 = (np.abs(self.pressure_surfaces().value - p1)).argmin()
        cdef int indx_p2 = (np.abs(self.pressure_surfaces().value - p2)).argmin()

        # Prediction from Recurrent Neural Network.
        cdef np.ndarray prediction_ai_temp, prediction_ai_height, prediction_ai_rh
        cdef int iterator_ai
        if self.ai:
            prediction_ai = self.model_prediction()
            prediction_ai_height = prediction_ai[2] * self.units.m
            prediction_ai_temp = prediction_ai[0] * self.units.K
            prediction_ai_rh = prediction_ai[1] * self.units.percent
            iterator_ai = 0

        # Define variable types.
        # Numy Arrays.
        cdef np.ndarray geo_0, geo_n, T_0, T_n, q_0, q_n, u_0, u_n, v_0, v_n
        cdef np.ndarray geostrophic_vorticity, A, A_diffx, A_diffy, Part_1
        cdef np.ndarray dT_dx, dT_dy, dT_dp, nabla_T, B, dB_dp, Part_2, RHS_geo
        cdef np.ndarray change_geopotential, du_dx, du_dy, du_dp, dv_dx, dv_dy, dv_dp, 
        cdef np.ndarray C, D, E, RHS, dq_dx, dq_dy, dq_dp, e, T_c, sat_vapor_pressure
        cdef bool break_loop
        # Lists.
        cdef list geopotential_height, temperature, virtual_temperature
        cdef list zonal_wind, meridional_wind, static_stability 
        cdef list relative_humidity, mixing_ratio, pressure_thickness
        cdef list precipitable_water

        # Create a bar to determine progress.
        max_bar = len(time)
        bar = IncrementalBar('Progress', max=max_bar)
        # Start progress bar.
        bar.next()

        # Define lists for ouputs.
        # Geopotential Height.
        geopotential_height = []
        geopotential_height.append(height.value)
        # Temperature.
        # Air Temperature.
        temperature = []
        temperature.append(T_i.value)
        # Virtual Temperature.
        virtual_temperature = []
        virtual_temperature.append(T_v.value)
        # Geostrophic Wind.
        # Zonal Wind.
        zonal_wind = []
        zonal_wind.append(u.value)
        # Meridional Wind.
        meridional_wind = []
        meridional_wind.append(v.value)
        # Vertical Motion.
        vertical_motion = []
        vertical_motion.append(omega.value)
        # Static Stability.
        static_stability = []
        static_stability.append(sigma.value)
        # Relative Humidity.
        relative_humidity = []
        relative_humidity.append(rh.value)
        # Mixing Ratio.
        mixing_ratio = []
        mixing_ratio.append(q_i.value)
        # Pressure Thickness.
        pressure_thickness = []
        pressure_thickness.append(thickness.value)
        # Precipitable Water.
        precipitable_water = []
        precipitable_water.append(pwv.value)

        cdef int n = 0
        try:
            while t < forecast_length.value:
                # Define initial state.
                # Geopotential.
                if n > 2:
                    geo_0 = geo
                    geo = geo_n

                # Wind.
                # Zonal Wind.
                if n > 2:
                    u_0 = u
                    u = u_n

                # Meridional Wind.
                if n > 2:
                    v_0 = v
                    v = v_n

                # Temperature.
                if n > 2:
                    T_0 = T
                    T = T_n
                
                # Mixing ratio.
                if n > 2:
                    q_0 = q
                    q = q_n

                # The Prognostic Section for Geopotential Height (Height
                # Tendency Equation).
                # Geostrophic Vorticity.
                dv_dx = self.gradient_x(
                    parameter=np.gradient(
                        v_g, longitude, axis=2
                    )
                )
                du_dy = np.gradient(u_g, self.a * latitude, axis=1)
                geostrophic_vorticity = dv_dx - du_dy
                
                # Part (1).
                A = geostrophic_vorticity + f_beta
                A_diffx = self.gradient_x(
                    parameter=np.gradient(
                        A, longitude, axis=2
                    )
                )
                A_diffy = np.gradient(A, self.a * latitude, axis=1)
                Part_1 = f_0 * (
                    (-u_g * A_diffx) + (-v_g * A_diffy)
                )

                # The derivative of temperature with respect to latitude
                # and longitude.
                dT_dx = self.gradient_x(
                    parameter=np.gradient(
                        T, longitude, axis=2
                    )
                )
                dT_dy = np.gradient(T, self.a * latitude, axis=1)

                # Part (2)
                nabla_T = -u_g * dT_dx + -v_g * dT_dy
                
                B = (self.R / pressure_3d) * nabla_T
                dB_dp = np.gradient(B, pressure, axis=0)

                Part_2 = ((f_0 ** 2) / sigma) * dB_dp

                RHS_geo = Part_1 - Part_2
                RHS_geo *= -1

                # Change with respect to time for geopotential.
                if n == 0:
                    RHS_geo = RHS_geo * delta_halfstep
                else:
                    RHS_geo = RHS_geo * delta_2t
                change_geopotential = RHS_geo.value * geo.unit

                if n == 0:
                    geo = geo_i + change_geopotential
                elif n == 1:
                    geo = geo_i + change_geopotential
                elif n == 2:
                    geo_n = geo_i + change_geopotential
                else:
                    geo_n = geo_0 + change_geopotential
                    # Apply Robert-Asselin time filter.
                    geo = geo + 0.1 * (geo_n - 2*geo + geo_0)
                
                # Convert to geopotential height.
                height = geo / g

                # Pressure thickness.
                thickness = height[indx_p2] - height[indx_p1]

                # Wind
                # Scalar gradients of geopotential height.
                dz_dx = self.gradient_x(
                    parameter=np.gradient(
                        height, longitude, axis=2
                    )
                )
                dz_dy = np.gradient(height, self.a * latitude, axis=1)

                # Zonal Wind.
                # Scalar gradients of wind wind.
                du_dx = self.gradient_x(
                    parameter=np.gradient(
                        u, longitude, axis=2
                    )
                )
                du_dy = np.gradient(u, self.a * latitude, axis=1)
                du_dp = np.gradient(u, pressure, axis=0)

                # Determine each term in the zonal momentum equation.
                A = -u * du_dx
                B = -v * du_dy
                C = -omega * du_dp
                D = -g * dz_dx
                E = f * v

                # Sum the RHS terms and multiple by the time step.
                if n == 0:
                    RHS = (A + B + C + D + E) * delta_halfstep
                else:
                    RHS = (A + B + C + D + E) * delta_2t

                if n == 0:
                    u = u_i + RHS
                elif n == 1:
                    u = u_i + RHS
                elif n == 2:
                    u_n = u_i + RHS
                else:
                    u_n[:, 1:-1, 1:-1] = u_0[:, 1:-1, 1:-1] + RHS[:, 1:-1, 1:-1]
                    # Apply Robert-Asselin time filter.
                    u = u + 0.1 * (u_n - 2*u + u_0)

                # Smoothing operator (filter with normal distribution
                # of weights).
                u = smooth_gaussian(
                    scalar_grid=u.value,
                    n=3,
                ).magnitude * u.unit

                # Meridional Wind.
                # Scalar gradients of wind wind.
                dv_dx = self.gradient_x(
                    parameter=np.gradient(
                        v, longitude, axis=2
                    )
                )
                dv_dy = np.gradient(v, self.a * latitude, axis=1)
                dv_dp = np.gradient(v, pressure, axis=0)

                # Determine each term in the meridional momentum equation.
                A = -u * dv_dx
                B = -v * dv_dy
                C = -omega * dv_dp
                D = -g * dz_dy
                E = -f * u

                # Sum the RHS terms and multiple by the time step.
                if n == 0:
                    RHS = (A + B + C + D + E) * delta_halfstep
                else:
                    RHS = (A + B + C + D + E) * delta_2t

                if n == 0:
                    v = v_i + RHS
                elif n == 1:
                    v = v_i + RHS
                elif n == 2:
                    v_n = v_i + RHS
                else:
                    v_n[:, 1:-1, 1:-1] = v_0[:, 1:-1, 1:-1] + RHS[:, 1:-1, 1:-1]
                    # Apply Robert-Asselin time filter.
                    v = v + 0.1 * (v_n - 2*v + v_0)

                # Smoothing operator (filter with normal distribution
                # of weights).
                v = smooth_gaussian(
                    scalar_grid=v.value,
                    n=3,
                ).magnitude * v.unit

                # Temperature.
                # Air Temperature.
                # Vertical scalar gradient of temperature.
                dT_dp = np.gradient(T, pressure, axis=0)

                # Thermodynamic Equation.
                A = -u * dT_dx
                B = -v * dT_dy
                C = -omega * dT_dp
                D = omega * ((self.R * T) / (pressure_3d * self.c_p))
                # Radiative forcing needs to be added!!!!!!!
                
                if n == 0:
                    RHS = (A + B + C + D) * delta_halfstep
                else:
                    RHS = (A + B + C + D) * delta_2t

                if n == 0:
                    T = T_i + RHS
                elif n == 1:
                    T = T_i + RHS
                elif n == 2:
                    T_n = T_i + RHS
                else:
                    T_n[:, 1:-1, 1:-1] = T_0[:, 1:-1, 1:-1] + RHS[:, 1:-1, 1:-1]
                    # Apply Robert-Asselin time filter.
                    T = T + 0.1 * (T_n - 2*T + T_0)
                
                # Smoothing operator (filter with normal distribution
                # of weights).
                T = smooth_gaussian(
                    scalar_grid=T.value,
                    n=3,
                ).magnitude * T.unit

                # Mixing ratio
                # The scalar gradients of the mixing ratio.
                dq_dx = self.gradient_x(
                    parameter=np.gradient(
                        q, longitude, axis=2
                    )
                )
                dq_dy = np.gradient(q, self.a * latitude, axis=1)
                dq_dp = np.gradient(q, pressure, axis=0)

                # Advect mixing ratio via wind. Sources and sinks
                # need to be added later!!!!!!
                A = -u * dq_dx
                B = -v * dq_dy
                C = -omega * dq_dp
                
                if n == 0:
                    RHS = (A + B + C) * delta_halfstep
                else:
                    RHS = (A + B + C) * delta_2t

                if n == 0:
                    q = q_i + RHS
                elif n == 1:
                    q =q_i + RHS
                elif n == 2:
                    q_n = q_i + RHS
                else:
                    q_n[:, 1:-1, 1:-1] = q_0[:, 1:-1, 1:-1] + RHS[:, 1:-1, 1:-1]
                    # Apply Robert-Asselin time filter.
                    q = q + 0.1 * (q_n - 2*q + q_0)

                # Smoothing operator (filter with normal distribution
                # of weights).
                q = smooth_gaussian(
                    scalar_grid=q.value,
                    n=3,
                ).magnitude * q.unit

                # Vapor pressure.
                e = pressure_3d * q / (0.622 + q)

                # Convert temperature in Kelvin to degrees centigrade.
                T_c = T.value - 273.15
                # Saturated vapor pressure.
                sat_vapor_pressure = 0.61121 * np.exp(
                    (
                        18.678 - (T_c / 234.5)
                    ) * (T_c / (257.14 + T_c)
                    )
                ) 
                # Add units of measurement.
                sat_vapor_pressure *= self.units.kPa
                sat_vapor_pressure = sat_vapor_pressure.to(self.units.hPa)

                # Relative Humidity.
                rh = (e.value / sat_vapor_pressure.value) * 100
                rh[rh > 100] = 100
                rh[rh < 0] = 0
                rh *= self.units.percent

                # Recurrent Neural Network.
                if self.ai:
                    # Apply predictions every six hours.
                    if t != 0 and t % 21600 == 0:
                        # Geopotential Height.
                        height = (height + prediction_ai_height[iterator_ai]) / 2
                        # Temperature. 
                        T = (T + prediction_ai_temp[iterator_ai]) / 2
                        # Relative Humidity.
                        rh = (rh + prediction_ai_rh[iterator_ai]) / 2
                        # Iterator.
                        iterator_ai += 1
                
                # Configure the Wind class, so, that it aligns with the
                # paramaters defined by the user.
                break_loop = False
                while not break_loop:
                    try:
                        config = Wind(
                            delta_latitude=self.delta_latitude,
                            delta_longitude=self.delta_longitude,
                            remove_files=self.remove_files,
                            input_data=True, 
                            geo=height, 
                            temp=T, 
                            rh=rh,
                            u=u,
                            v=v 
                        )
                        break_loop = True
                    except:
                        pass

                # Geostrophic Wind.
                geostrophic_wind = self.geostrophic_wind()
                
                # Geostrophic Wind.
                # Zonal Wind.
                u_g = geostrophic_wind[0]
                # Meridional Wind.
                v_g = geostrophic_wind[1]

                # Virtual Temperature.
                T_v = config.virtual_temperature()

                # Static Stability.
                sigma = config.static_stability()

                # Precipitable Water.
                pwv = config.precipitable_water()

                # Gravitational Acceleration.
                g = config.gravitational_acceleration()

                # Append predictions to list.
                if n > 1:
                    # Geopotential Height.
                    geopotential_height.append(height.value)
                    # Geostrophic Wind.
                    # Zonal Wind.
                    zonal_wind.append(u.value)
                    # Meridional Wind.
                    meridional_wind.append(v.value)
                    # Static Stability
                    static_stability.append(sigma.value)
                    # Temperature.
                    # Air Temperature.
                    temperature.append(T.value)
                    # Virtual Temperature.
                    virtual_temperature.append(T_v.value)
                    # Relative Humidity.
                    relative_humidity.append(rh.value)
                    # Mixing Ratio.
                    mixing_ratio.append(q.value)
                    # Thickness.
                    pressure_thickness.append(thickness.value)
                    # Precipitable Water.
                    precipitable_water.append(pwv.value)

                    # Add time step.
                    t += delta_t.value
                    bar.next()
                
                n += 1
        except KeyboardInterrupt:
            cutpoint = len(precipitable_water) 
            time = time[:cutpoint]

        # Convert lists to NumPy arrays, and clear variables from memory.
        cdef np.ndarray GeopotentialHeight = np.asarray(geopotential_height)
        del geopotential_height
        cdef np.ndarray ZonalWind = np.asarray(zonal_wind)
        del zonal_wind
        cdef np.ndarray MeridionalWind = np.asarray(meridional_wind)
        del meridional_wind
        cdef np.ndarray StaticStability = np.asarray(static_stability)
        del static_stability
        cdef np.ndarray AirTemperature = np.asarray(temperature)
        del temperature
        cdef np.ndarray VirtualTemperature = np.asarray(virtual_temperature)
        del virtual_temperature
        cdef np.ndarray RelativeHumidity = np.asarray(relative_humidity)
        del relative_humidity
        cdef np.ndarray MixingRatio = np.asarray(mixing_ratio)
        del mixing_ratio
        cdef np.ndarray Thickness = np.asarray(pressure_thickness)
        del pressure_thickness
        cdef np.ndarray PrecipitableWater = np.asarray(precipitable_water)
        del precipitable_water 

        # Finish progress bar.
        bar.finish()

        # Define the coordinates for the cube. 
        # Latitude.
        lat = DimCoord(
            self.latitude_lines(),
            standard_name='latitude',
            units='degrees'
        )
        # Longitude
        lon = DimCoord(
            self.longitude_lines(),
            standard_name='longitude', 
            units='degrees'
        )
        # Pressure Surfaces.
        p = DimCoord(
            pressure,
            long_name='pressure', 
            units='hPa'
        )
        # Time.
        forecast_period = DimCoord(
            time,
            standard_name='forecast_period', 
            units='hours'
        )
        # Forecast reference time.
        ref_time = AuxCoord(
            self.date.strftime("%Y-%m-%d %H:%M:%S"),
            standard_name='forecast_reference_time'
        )

        # Cubes
        # Geopotential Height Cube.
        height_cube = Cube(GeopotentialHeight,
            standard_name='geopotential_height',
            units='m',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        height_cube.add_aux_coord(ref_time)
        # Geostrophic Wind Cubes.
        # Zonal Wind Cube.
        u_cube = Cube(ZonalWind,
            standard_name='x_wind',
            units='m s-1',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        u_cube.add_aux_coord(ref_time)
        # Meridional Wind Cube.
        v_cube = Cube(MeridionalWind,
            standard_name='y_wind',
            units='m s-1',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        v_cube.add_aux_coord(ref_time)
        # Static Stability.
        sigma_cube = Cube(StaticStability,
            long_name='static_stability',
            units='J hPa-2 kg-1',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        sigma_cube.add_aux_coord(ref_time)
        # Temperature.
        # Air Temperature.
        T_cube = Cube(AirTemperature,
            standard_name='air_temperature',
            units='K',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        T_cube.add_aux_coord(ref_time)
        # Virtual Temperature.
        Tv_cube = Cube(VirtualTemperature,
            standard_name='virtual_temperature',
            units='K',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        Tv_cube.add_aux_coord(ref_time)
        # Relative Humidity.
        rh_cube = Cube(RelativeHumidity,
            standard_name='relative_humidity',
            units='%',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        rh_cube.add_aux_coord(ref_time)
        # Mixing Ratio.
        q_cube = Cube(MixingRatio,
            long_name='mixing_ratio',
            dim_coords_and_dims=[
                (forecast_period, 0), (p, 1), (lat, 2), (lon, 3)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        q_cube.add_aux_coord(ref_time)
        # Pressure Thickness.
        thickness_cube = Cube(Thickness,
            long_name='pressure_thickness',
            units='m',
            dim_coords_and_dims=[
                (forecast_period, 0), (lat, 1), (lon, 2)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        thickness_cube.add_aux_coord(ref_time)
        # Precipitable Water.
        pwv_cube = Cube(PrecipitableWater,
            long_name='precipitable_water',
            units='mm',
            dim_coords_and_dims=[
                (forecast_period, 0), (lat, 1), (lon, 2)
            ],
            attributes={
                'source': 'Motus Aeris @ AMSIMP',
            }
        )
        pwv_cube.add_aux_coord(ref_time)

        # Create Cube list of output parameters.
        output = CubeList([
            height_cube,
            u_cube,
            v_cube,
            sigma_cube,
            T_cube,
            Tv_cube,
            rh_cube,
            q_cube,
            thickness_cube,
            pwv_cube
        ])

        # If specified, save the forecast in the file format, .nc.
        if save_file:
            # Establish the file name.
            filename = 'motusaeris_amsimp_' + str(self.date.year)
            filename += str(self.date.month) + str(self.date.day)
            filename += str(self.date.hour) + '.nc'

            # Save.
            save(output, filename)

        return output

    def simulate(self, data=None):
        """
        Explain here.
        """
        if data == None:
            raise Exception("The dataset for simulation must be defined.")

        # Define the forecast period.
        time = data

        # Style of graph.
        style.use("fivethirtyeight")

        # Define layout.
        gs = gridspec.GridSpec(2, 2)
        fig = plt.figure(figsize=(18.5, 7.5))
        fig.subplots_adjust(hspace=0.340, bottom=0.105, top=0.905)
        plt.ion()

        # Temperature
        indx_long = (np.abs(self.longitude_lines().value - 0)).argmin()
        ax1 = plt.subplot(gs[0, 0])
        forecast_temp = data
        # Geopotential Height
        ax2 = plt.subplot(gs[1, 0], projection=ccrs.EckertIII())
        forecast_height = data
        # Precipitable Water
        ax3 = plt.subplot(gs[0, 1], projection=ccrs.EckertIII())
        forecast_Pwv = data
        # Pressure Thickness (1000hPa - 500hPa).
        ax4 = plt.subplot(gs[1, 1], projection=ccrs.EckertIII())
        forecast_pthickness = data

        # Troposphere - Stratosphere Boundary Line
        trop_strat_line = self.troposphere_boundaryline().value
        trop_strat_line = np.mean(trop_strat_line) + np.zeros(
            len(trop_strat_line)
        )

        t = 0
        while t < len(time):
            # Defines the axes.
            # For the temperature contour plot.
            latitude, pressure = np.meshgrid(
                self.latitude_lines().value, self.pressure_surfaces().value
            )
            # For the geopotential height, precipitable water, and pressure 
            # thickness countour plot
            lat, long = np.meshgrid(
                self.latitude_lines().value, self.longitude_lines().value
            )
            
            # Temperature contour plot.
            # Temperature data.
            temperature = forecast_temp[t]
            temperature = temperature[:, :, indx_long]

            # Contour plotting.
            cmap1 = plt.get_cmap("hot")
            min1 = np.min(forecast_temp[0])
            max1 = np.max(forecast_temp[0])
            level1 = np.linspace(min1, max1, 21)
            temp = ax1.contourf(
                latitude, pressure, temperature, cmap=cmap1, levels=level1
            )

            # Checks for a colorbar.
            if t == 0:
                cb1 = fig.colorbar(temp, ax=ax1)
                tick_locator = ticker.MaxNLocator(nbins=10)
                cb1.locator = tick_locator
                cb1.update_ticks()
                cb1.set_label("Temperature (K)")

            # Add SALT to the graph.
            ax1.set_xlabel("Latitude ($\phi$)")
            ax1.set_ylabel("Pressure (hPa)")
            ax1.set_yscale('log')
            ax1.set_title("Temperature")

            # Geopotential height contour.
            # Geopotential height data.
            height = forecast_height[t]
            height = height[0, :, :]
            height = np.transpose(height)

            # EckertIII projection details.
            ax2.set_global()
            ax2.coastlines()
            ax2.gridlines()

            # Contourf plotting.
            height_sealevel = np.asarray(forecast_height)
            height_sealevel = height_sealevel[:, 0, :, :]
            cmap2 = plt.get_cmap("jet")
            min2 = np.min(height_sealevel)
            max2 = np.max(height_sealevel)
            level2 = np.linspace(min2, max2, 21)
            geopotential_height = ax2.contourf(
                long,
                lat,
                height,
                cmap=cmap2,
                levels=level2,
                transform=ccrs.PlateCarree(),
            )

            # Checks for a colorbar.
            if t == 0:
                cb2 = fig.colorbar(geopotential_height, ax=ax2)
                tick_locator = ticker.MaxNLocator(nbins=10)
                cb2.locator = tick_locator
                cb2.update_ticks()
                cb2.set_label("Pressure (hPa)")

            # Add SALT to the graph.
            ax2.set_xlabel("Longitude ($\lambda$)")
            ax2.set_ylabel("Latitude ($\phi$)")
            ax2.set_title(
                "Geopotential Height (Pressure = " 
                + str(self.pressure_surfaces()[0])
                + ")"
            )

            # Precipitable water contour.
            # Precipitable water data.
            precipitable_water = forecast_Pwv[t, :, :]
            precipitable_water = np.transpose(precipitable_water)
            print(precipitable_water.ndim)

            # EckertIII projection details.
            ax3.set_global()
            ax3.coastlines()
            ax3.gridlines()

            # Contourf plotting.
            cmap3 = plt.get_cmap("seismic")
            min3 = np.min(forecast_Pwv[0])
            max3 = np.max(forecast_Pwv[0])
            level3 = np.linspace(min3, max3, 21)
            precipitable_watervapour = ax3.contourf(
                long,
                lat,
                precipitable_water,
                cmap=cmap3,
                levels=level3,
                transform=ccrs.PlateCarree(),
            )

            # Checks for a colorbar.
            if t == 0:
                cb3 = fig.colorbar(precipitable_watervapour, ax=ax3)
                tick_locator = ticker.MaxNLocator(nbins=10)
                cb3.locator = tick_locator
                cb3.update_ticks()
                cb3.set_label("Precipitable Water (mm)")

            # Add SALT to the graph.
            ax3.set_xlabel("Longitude ($\lambda$)")
            ax3.set_ylabel("Latitude ($\phi$)")
            ax3.set_title("Precipitable Water")

            # Pressure thickness scatter plot.
            # Pressure thickness data.
            pressure_thickness = forecast_pthickness[t]
            pressure_thickness = np.transpose(pressure_thickness)

            # EckertIII projection details.
            ax4.set_global()
            ax4.coastlines()
            ax4.gridlines()

            # Contourf plotting.
            min4 = np.min(forecast_pthickness)
            max4 = np.max(forecast_pthickness)
            level4 = np.linspace(min4, max4, 21)
            pressure_h = ax4.contourf(
                long,
                lat,
                pressure_thickness,
                transform=ccrs.PlateCarree(),
                levels=level4,
            )

            # Index of the rain / snow line
            indx_snowline = (np.abs(level4 - 5400)).argmin()
            pressure_h.collections[indx_snowline].set_color('black')
            pressure_h.collections[indx_snowline].set_linewidth(1) 

            # Add SALT.
            ax4.set_xlabel("Latitude ($\phi$)")
            ax4.set_ylabel("Longitude ($\lambda$)")
            ax4.set_title("Thickness (1000 hPa - 500 hPa)")

            # Checks for a colorbar.
            if t == 0:
                cb4 = fig.colorbar(pressure_h, ax=ax4)
                tick_locator = ticker.MaxNLocator(nbins=10)
                cb4.locator = tick_locator
                cb4.update_ticks()
                cb4.set_label("Pressure Thickness (m)")

            # Plots the average boundary line on two contourfs.
            # Temperature contourf.
            ax1.plot(
                latitude[1],
                trop_strat_line,
                color="black",
                linestyle="dashed",
                label="Troposphere - Stratosphere Boundary Line",
            )
            ax1.legend(loc=0)

            fig.suptitle(
                "Motus Aeris @ AMSIMP"
            )

            # Displaying simualtion.
            plt.show()
            plt.pause(0.01)
            if t < (len(time) - 1):
                ax1.clear()
                ax2.clear()
                ax3.clear()
                ax4.clear()
            else:
                plt.pause(10)

            note = (
                "Note: Rain / Snow Line is marked on the Pressure Thickness" 
                + " contour plot by the black line (5,400 m)."
            )

            # Footnote
            plt.figtext(
                0.99,
                0.01,
                note,
                horizontalalignment="right",
                fontsize=10,
            )

            t += 1
