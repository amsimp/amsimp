#cython: linetrace=True
#distutils: define_macros=CYTHON_TRACE_NOGIL=1
#cython: language_level=3
"""
AMSIMP Backend Class. For information about this class is described below.

Copyright (C) 2020 AMSIMP

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

# -----------------------------------------------------------------------------------------#

# Importing Dependencies
import os, sys
from datetime import datetime
import socket
from amsimp.download cimport Download
from amsimp.download import Download
import numpy as np
from astropy import constants as constant
from astropy import units
from astropy.units.quantity import Quantity
cimport numpy as np
from cpython cimport bool
import matplotlib.pyplot as plt
from matplotlib import ticker
import cartopy.crs as ccrs
from cartopy.util import add_cyclic_point
import iris
from iris.coords import DimCoord
from iris.cube import Cube
from iris.coord_systems import GeogCS

# -----------------------------------------------------------------------------------------#


cdef class Backend(Download):
    """
    AMSIMP Backend Class - This is the base class for AMSIMP, as such, all
    other classes within AMSIMP inherit this class, either directly or
    indirectly.

    For methods to be included in this class they must meet one of the following
    criteria:
    (1) they are considered essential components of the software.
    (2) the output of these methods are generated solely from the methods
    classified as (1).
    (3) these methods import data from the Global Data Assimilation System.
    This data is retrieved from the AMSIMP data repository, which is updated 
    every hour.
    (4) they don't classify nicely into any other class.
    (5) they offer a visualisation of any of the methods found in this class.
    
    Below is a list of the methods included within this class, with a short
    description of their intended purpose and a bracketed number signifying
    which of the above criteria they meet. Please see the relevant class methods
    for more information. Please note that the unit information with AMSIMP
    is provided by the unit module within astropy.

    latitude_lines ~ generates a NumPy array of latitude lines (1). The unit
    of measurement is degrees.
    longitude_lines ~ generates a NumPy array of longitude lines (1). The unit
    of measurement is degrees.
    pressure_surfaces ~ generates a NumPy array of constant pressure
    surfaces (1). The unit of measurement is hectopascals. This is the
    isobaric coordinate system.

    coriolis_parameter ~ generates a NumPy arrray of the Coriolis parameter
    at various latitudes of the Earth's surface (2). The unit of measurement
    is radians per second.

    geopotential_height ~ outputs a NumPy array of geopotential height (3). The
    unit of measurement is metres.
    relative_humidity ~ outputs a NumPy array of relative humidity (3). The unit
    of measurement is percentage.
    temperature ~ outputs a NumPy array of temperature (3). The unit of
    measurement is Kelvin.
    remove_all_files ~ this method deletes any file created by the software,
    whilst downloading data from the AMSIMP Initial Atmospheric Conditions
    Data Repository (3). It does not, however, delete any forecast generated by,
    the, simulate, method. Please note that you may specifcy whether you would like
    to save such files throught the utilisation of the parameter, remove_files,
    when the class is initialised.
    
    pressure_thickness ~ outputs a NumPy array of atmospheric pressure
    thickness (4). The unit of measurement is metres.
    troposphere_boundaryline ~ generates a NumPy array of the
    troposphere - stratosphere boundary line (4). The unit of measurement is
    metres.
    
    longitude_contourf ~ generates a contour plot for a desired atmospheric
    process, with the axes being latitude, and longitude (5).
    altitude_contourf ~ generates a contour plot for a desired atmospheric
    process, with the axes being latitude, and altitude (5).
    thickness_contourf ~ generates a contour plot for pressure thickness,
    with the axes being latitude and longitude. This plot is then layed
    on top of a EckertIII global projection (5).
    """

    # Define units of measurement for AMSIMP.
    units = units

    def __cinit__(
            self,
            int delta_latitude=5,
            int delta_longitude=5, 
            bool remove_files=False, 
            forecast_length=72, 
            delta_t=2, 
            bool ai=True, 
            data_size=150, 
            epochs=200, 
            input_date=None, 
            bool input_data=False,
            psurfaces=None,
            lat=None,
            lon=None,
            height=None, 
            temp=None, 
            rh=None, 
            u=None, 
            v=None,
            dict constants={
                "sidereal_day": (23 + (56 / 60)) * 3600,
                "angular_rotation_rate": ((2 * np.pi) / ((23 + (56 / 60)) * 3600)),
                "planet_radius": constant.R_earth.value,
                "planet_mass": constant.M_earth.value,
                "specific_heat_capacity_psurface": 1004,
                "gravitational_acceleration": 9.80665 
            }
        ):
        """
        The parameters, delta_latitude and delta_longitude, defines the
        horizontal resolution between grid points within the software. The
        parameter values must be between 1 and 10 degrees if you are utilising
        the default initial conditions included within the software. Defaults
        to a value of 5 degrees. 
        
        The parameter, remove_files, is a boolean value, and when set to True,
        it will remove any file downloaded from the AMSIMP Initial Atmospheric
        Conditions Data Repository.

        The parameter, input_date, allows the end-user to specify the initial
        date at which the forecast is generated from. Please note that
        currently you cannot specify dates before Janurary 2020. Please also
        note that the latest data available to the software is typically
        from three days ago. This is due to the rate at which the NOAA
        updates the data on the Global Data Assimilation System website. This
        feature is intended for situations where the default initial conditions
        included within the software are being used.

        The parameter, input_data, is a boolean value, and when set to True,
        it will allow the end-user to provide their own initial conditions
        to the software. Please note that this feature has not been fully
        tested as of this moment, and such is experimental for the time
        being.

        The parameter, ai, is a boolean value, and when set to True, a 
        recurrent neural network will be trained on the amount of days 
        specified by the parameter, data_size. A prediction by the
        recurrent neural network will be generated, and will be 
        combined with a traditional physical model of the atmosphere.
        It can also be used independently. 
        """
        # Make the aforementioned variables available else where in the class.
        self.delta_latitude = delta_latitude
        self.delta_longitude = delta_longitude
        self.remove_files = remove_files
        self.input_date = input_date
        self.input_data = input_data

        # The date at which the initial conditions was gathered (i.e. how
        # recent the data is).
        if self.input_date == None:
            data_date_file = self.download(
                "https://github.com/amsimp/initial-conditions/raw/master/date.npy", 
                bar=False,
            )
            data_date = np.load(data_date_file)
            os.remove(data_date_file)
            date = datetime(
                int(data_date[2]),
                int(data_date[1]),
                int(data_date[0]),
                int(data_date[3]),
            )
            self.date = date
        else:        
            # Ensure input_date is of the type "datetime.datetime".
            if type(self.input_date) != datetime:
                raise Exception(
                    "input_date must of the type 'datetime.datetime'. The value of input_date was: {}".format(
                        self.input_date
                    )
                )
            date = self.input_date
            self.date = date

        # Ensure input_data is a boolean value.
        if not isinstance(self.input_data, bool):
            raise Exception(
                "input_data must be a boolean value. The value of input_data was: {}".format(
                    self.input_data
                )
            )

        # Function to ensure that the input data is 3 dimensional.
        def dimension(input_variable):
            if np.ndim(input_variable) != 3:
                raise Exception(
                    "All input data variables (height, rh, temp, u, v) must be a 3 dimensional."
                )

        # Function to check if a function is a NumPy array, or a list.
        def type_check(input_variable):
            if type(input_variable) == Quantity:
                pass
            elif type(input_variable) == np.ndarray:
                pass
            elif type(input_variable) == list:
                pass
            else:
                raise Exception(
                    "All input data variables must be either NumPy arrays, or lists."
                )
        
        # Function to check if grid input variables are 1 dimensional.
        def dimension_grid(input_variable):
            if np.ndim(input_variable) != 1:
                raise Exception(
                    "All grid input variables (psurfaces, lat, lon) must be a 1 dimensional."
                )

        # Function to convert input lists into NumPy arrays.
        def list_to_numpy(input_variable):
            if type(input_variable) == list:
                input_variable = np.asarray(input_variable)
            
            return input_variable

        if self.input_data:
            # Ensure input data variables are either NumPy arrays, or lists.
            type_check(psurfaces)
            type_check(lat)
            type_check(lon)
            type_check(height)
            type_check(rh)
            type_check(temp)
            type_check(u)
            type_check(v)

            # Check if grid input variables are 1 dimensional.
            dimension_grid(psurfaces)
            dimension_grid(lat)
            dimension_grid(lon)

            # Check if input data is 3 dimensional.
            dimension(height)
            dimension(rh)
            dimension(temp)
            dimension(u)
            dimension(v)

            # Convert input data lists to NumPy arrays.
            list_to_numpy(psurfaces)
            list_to_numpy(lat)
            list_to_numpy(lon)
            list_to_numpy(height)
            list_to_numpy(rh)
            list_to_numpy(temp)
            list_to_numpy(u)
            list_to_numpy(v)

            # Add units to input variables.
            # psurfaces variable.
            if type(psurfaces) != Quantity:
                psurfaces = psurfaces * units.hPa
            # lat variable.
            if type(lat) != Quantity:
                lat = lat * units.deg
            # lon variable.
            if type(height) != Quantity:
                lon = lon * units.deg
            # height variable.
            if type(height) != Quantity:
                height = height * units.m
            # rh variable.
            if type(rh) != Quantity:
                rh = rh * units.percent
            # temp variable.
            if type(temp) != Quantity:
               temp = temp * units.K
            # u variable.
            if type(u) != Quantity:
               u = u * (units.m / units.s)
            # v variable.
            if type(v) != Quantity:
               v = v * (units.m / units.s)

        # Ensure self.delta_latitude is between 1 and 10 degrees.
        if not input_data:
            if self.delta_latitude > 10 or self.delta_latitude < 1:
                raise Exception(
                    "delta_latitude must be a positive integer between 1 and 10. The value of delta_latitude was: {}".format(
                        self.delta_latitude
                    )
                )

            # Ensure self.delta_longitude is between 1 and 10 degrees.
            if self.delta_longitude > 10 or self.delta_longitude < 1:
                raise Exception(
                    "delta_longitude must be a positive integer between 1 and 10. The value of delta_longitude was: {}".format(
                        self.delta_longitude
                    )
                )

            folder = "https://github.com/amsimp/initial-conditions/raw/master/initial_conditions/"

            # Define date.
            year = self.date.year
            month = self.date.month
            day = self.date.day
            hour = self.date.hour

            # Adds zero before single digit numbers.
            if day < 10:
                day = "0" + str(day)

            if month < 10:
                month =  "0" + str(month)

            if hour < 10:
                hour = "0" + str(hour)

            # Converts integers to strings.
            day = str(day)
            month = str(month)
            year = str(year)
            hour = str(hour)

            folder += (
                year + "/" + month + "/" + day + "/" + hour + "/"
            )
            # The url to the NumPy pressure surfaces file stored on the AMSIMP
            # Initial Conditions Data repository.
            url = folder + "initial_conditions.nc"

            # Download the NumPy file and store the NumPy array into a variable.
            try:
                cube = iris.load("initial_conditions.nc")
            except OSError:  
                fname = self.download(url)
                cube = iris.load(fname)
            
            height = cube.extract("geopotential_height")[0]
            temp = cube.extract("air_temperature")[0]
            rh = cube.extract("relative_humidity")[0]
            u = cube.extract("x_wind")[0]
            v = cube.extract("y_wind")[0]

        # Constants dictionary.
        # Sidereal day.
        if type(constants["sidereal_day"]) != Quantity:
            constants["sidereal_day"] = constants["sidereal_day"] * units.s
        # Angular rotation rate.
        if type(constants["angular_rotation_rate"]) != Quantity:
            constants["angular_rotation_rate"] = constants["angular_rotation_rate"] * (
                units.rad / units.s
            )
        # Planet radius.
        if type(constants["planet_radius"]) != Quantity:
            constants["planet_radius"] = constants["planet_radius"] * units.m
        # Planet mass.
        if type(constants["planet_mass"]) != Quantity:
            constants["planet_mass"] = constants["planet_mass"] * units.kg
        # Specific heat capacity on a constant pressure surface.
        if type(constants["specific_heat_capacity_psurface"]) != Quantity:
            constants["specific_heat_capacity_psurface"] = constants[
                "specific_heat_capacity_psurface"
            ] * (units.J / (units.kg * units.K))
        # Gravitational acceleration.
        if type(constants["gravitational_acceleration"]) != Quantity: 
            constants["gravitational_acceleration"] = constants["gravitational_acceleration"] * (
                units.m / (units.s ** 2)
            )

        # Make the input data variables available else where in the class.
        self.psurfaces = psurfaces
        self.lat = lat
        self.lon = lon
        self.input_height = height
        self.input_rh = rh
        self.input_temp = temp
        self.input_u = u
        self.input_v = v
        self.constants = constants

        # Predefined Constants.
        # Angular rotation rate of the planet.
        self.sidereal_day = constants["sidereal_day"]
        self.Upomega = constants["angular_rotation_rate"]
        # Ideal Gas Constant
        self.R = 287 * (units.J / (units.kg * units.K))
        # Mean radius of the planet.
        self.a = self.constants["planet_radius"]
        # Universal Gravitational Constant.
        G = constant.G
        self.G = G.value * G.unit
        # Mass of the planet.
        self.M = self.constants["planet_mass"]
        # The specific heat capacity on a constant pressure surface.
        self.c_p = self.constants["specific_heat_capacity_psurface"]
        # Gravitational acceleration.
        self.g = self.constants["gravitational_acceleration"]

        # Function to check for an internet connection.
        def is_connected():
            try:
                host = socket.gethostbyname("www.github.com")
                s = socket.create_connection((host, 80), 2)
                s.close()
                return True
            except OSError:
                pass
            return False

        # Check for an internet connection.
        if not input_data:
            if not is_connected():
                raise Exception(
                    "You must connect to the internet in order to utilise AMSIMP."
                    + " Apologies for any inconvenience caused."
                )

        # RNN.
        self.epochs = epochs
        self.data_size = data_size

        # Ensure epochs is an integer value.
        if not isinstance(self.epochs, int):
            raise Exception(
                "epochs must be a integer value. The value of epochs was: {}".format(
                    self.ai
                )
            )

        # Ensure epochs is a natural number.
        if not self.epochs > 0:
            raise Exception(
                "epochs must be a integer value. The value of epochs was: {}".format(
                    self.ai
                )
            )

        # Ensure data_size is an integer value.
        if not isinstance(self.data_size, int):
            raise Exception(
                "data_size must be a integer value. The value of data_size was: {}".format(
                    self.ai
                )
            )

        # Ensure data_size is a natural number and is greater than 14.
        if not self.data_size > 14:
            raise Exception(
                "data_size must be a integer value. The value of data_size was: {}".format(
                    self.ai
                )
            )

    cpdef np.ndarray latitude_lines(self):
        """
        Generates a NumPy array of latitude lines.
        """
        cdef float i
        if not self.input_data:
            latitude_lines = [
                i
                for i in np.arange(
                    -89, 90, self.delta_latitude
                )
            ]

            # Convert list to NumPy array and add the unit of measurement.
            latitude_lines = np.asarray(latitude_lines) * units.deg
        else:
            latitude_lines = self.lat

        return latitude_lines
    
    cpdef np.ndarray longitude_lines(self):
        """
        Generates a NumPy array of longitude lines.
        """
        cdef float i
        if not self.input_data:
            longitude_lines = [
                i
                for i in np.arange(
                    0, 360, self.delta_longitude
                )
            ]

            # Convert list to NumPy array and add the unit of measurement.
            longitude_lines = np.asarray(longitude_lines) * units.deg
        else:
            longitude_lines = self.lon

        return longitude_lines

    cpdef np.ndarray pressure_surfaces(self, dim_3d=False):
        """
        Generates a NumPy array of the constant pressure surfaces. This
        is the isobaric coordinate system.
        """
        if not self.input_data:
            pressure_surfaces = self.input_rh.coords('pressure')[0].points
            pressure_surfaces = pressure_surfaces[::-1] * self.units.Pa
            pressure_surfaces = pressure_surfaces.to(self.units.hPa)
            pressure_surfaces = pressure_surfaces.value
        else:
            pressure_surfaces = self.psurfaces.value

        # Convert Pressure Array into 3D Array.
        if dim_3d:
            list_pressure = []
            for p in pressure_surfaces:
                p = np.zeros((
                    len(self.latitude_lines()), len(self.longitude_lines())
                )) + p
                
                p = p.tolist()
                list_pressure.append(p)
            pressure_surfaces = np.asarray(list_pressure)

        pressure_surfaces *= self.units.hPa
        return pressure_surfaces

    cpdef np.ndarray gradient_x(self, parameter=None):
        """
        Explain here.
        """
        cdef np.ndarray latitude = np.radians(self.latitude_lines().value)
        parameter = np.transpose(parameter, (1, 0, 2))

        cdef int len_latitude = len(latitude)
        cdef list parameter_list = []
        cdef int n = 0
        while n < len_latitude:
            param = (1 / (self.a * np.cos(latitude[n]))) * parameter[n]

            # Store the unit.
            unit = param.unit
            unit = unit.si

            param = param.value.tolist()
            parameter_list.append(param)

            n += 1

        parameter = np.asarray(parameter_list)
        gradient_x = np.transpose(parameter, (1, 0, 2)) * unit

        return gradient_x

    cpdef np.ndarray gradient_y(self, parameter=None):
        """
        Explain here.
        """
        cdef np.ndarray latitude = np.radians(self.latitude_lines().value)

        gradient_y = np.gradient(
            parameter.value, self.a * latitude, axis=1
        ) * (parameter.unit / units.m)
        return gradient_y
    
    cpdef np.ndarray gradient_p(self, parameter=None):
        """
        Explain here.
        """
        cdef np.ndarray pressure = self.pressure_surfaces()

        gradient_p = np.gradient(
            parameter.value, pressure, axis=0
        ) * (parameter.unit / pressure.unit)
        return gradient_p

    cpdef np.ndarray make_3dimensional_array(self, parameter=None, axis=1):
        """
        Explain here.
        """
        if axis == 0:
            a = self.latitude_lines().value
            b = self.longitude_lines().value
        elif axis == 1:
            a = self.pressure_surfaces().value
            b = self.longitude_lines().value
        elif axis == 2:
            a = self.pressure_surfaces().value
            b = self.latitude_lines().value

        list_parameter = []
        for param in parameter:
            unit = param.unit
            param = param.value + np.zeros((len(a), len(b)))
            param = param.tolist()
            list_parameter.append(param)
        parameter = np.asarray(list_parameter) * unit

        if axis == 1:
            parameter = np.transpose(parameter, (1, 0, 2))
        elif axis == 2:
            parameter = np.transpose(parameter, (1, 2, 0))
        
        return parameter

# -----------------------------------------------------------------------------------------

    cpdef np.ndarray coriolis_parameter(self):
        """
        Generates a NumPy arrray of the Coriolis parameter at various latitudes
        of the Earth's surface.
        
        The Coriolis parameter is defined as two times the angular rotation of
        the Earth by the sin of the latitude you are interested in.

        Equation:
            f_0 = 2 \* Upomega * sin(\phi)
        """
        coriolis_parameter = (
            2 * self.Upomega * np.sin(np.radians(self.latitude_lines()))
        )

        return coriolis_parameter

# -----------------------------------------------------------------------------------------#

    cpdef np.ndarray geopotential_height(self):
        """
        This method imports geopotential height data from a NetCDF file, which is
        located in the AMSIMP Initial Conditions Data Repository on GitHub.
        The data stored within this repo is updated every six hours by amsimp-bot.
        Following which, it outputs a NumPy array in the shape of
        (len(pressure_surfaces), len(latitude_lines), len(longitude_lines)).

        Geopotential Height is the height above sea level of a pressure level.
        For example, if a station reports that the 500 hPa height at its
        location is 5600 m, it means that the level of the atmosphere over
        that station at which the atmospheric pressure is 500 hPa is 5600
        meters above sea level.

        I strongly recommend storing the output into a variable in order to
        prevent the need to repeatly self.download the file. For more information,
        visit https://github.com/amsimp/initial-conditions.
        """
        if not self.input_data:
            # Input data.
            height = self.input_height

            pressure = self.pressure_surfaces().to(self.units.Pa)
            # Grid.
            grid_points = [
                ('pressure',  pressure.value),
                ('latitude',  self.latitude_lines().value),
                ('longitude', self.longitude_lines().value),                
            ]

            # Interpolation
            height = height.interpolate(
                grid_points, iris.analysis.Linear()
            )

            # Get data.
            geopotential_height = height.data
            geopotential_height = np.asarray(geopotential_height.tolist())

            geopotential_height *= self.units.m
        else:
            geopotential_height = self.input_height
        
        return geopotential_height

    cpdef np.ndarray relative_humidity(self):
        """
        This method imports relative humidity data from a NetCDF file, which is
        located in the AMSIMP Initial Conditions Data Repository on GitHub.
        The data stored within this repo is updated every six hours by amsimp-bot.
        Following which, it outputs a NumPy array in the shape of
        (len(pressure_surfaces), len(latitude_lines), len(longitude_lines)).
        
        Relative Humidity is the amount of water vapour present in air expressed
        as a percentage of the amount needed for saturation at the same temperature.

        I strongly recommend storing the output into a variable in order to
        prevent the need to repeatly self.download the file. For more information,
        visit https://github.com/amsimp/initial-conditions.
        """
        if not self.input_data:
            # Input data.
            rh = self.input_rh

            pressure = self.pressure_surfaces().to(self.units.Pa)
            # Grid.
            grid_points = [
                ('pressure',  pressure.value),
                ('latitude',  self.latitude_lines().value),
                ('longitude', self.longitude_lines().value),                
            ]

            # Interpolation
            rh = rh.interpolate(
                grid_points, iris.analysis.Linear()
            )

            # Get data.
            relative_humidity = rh.data
            relative_humidity = np.asarray(relative_humidity.tolist())

            relative_humidity *= self.units.percent
        else:
            relative_humidity = self.input_rh
        
        return relative_humidity

    cpdef np.ndarray temperature(self):
        """
        This method imports temperature data from a NetCDF file, which is
        located in the AMSIMP Initial Conditions Data Repository on GitHub.
        The data stored within this repo is updated every six hours by amsimp-bot.
        Following which, it outputs a NumPy array in the shape of
        (len(pressure_surfaces), len(latitude_lines), len(longitude_lines)).

        Temperature is defined as the mean kinetic energy density of molecular
        motion.

        I strongly recommend storing the output into a variable in order to
        prevent the need to repeatly self.download the file. For more information,
        visit https://github.com/amsimp/initial-conditions.
        """
        if not self.input_data:
            # Input data.
            temp = self.input_temp

            pressure = self.pressure_surfaces().to(self.units.Pa)
            # Grid.
            grid_points = [
                ('pressure',  pressure.value),
                ('latitude',  self.latitude_lines().value),
                ('longitude', self.longitude_lines().value),                
            ]

            # Interpolation
            temp = temp.interpolate(
                grid_points, iris.analysis.Linear()
            )

            # Get data.
            temperature = temp.data
            temperature = np.asarray(temperature.tolist())

            temperature *= self.units.K
        else:
            temperature = self.input_temp
        
        return temperature

    cpdef exit(self):
        """
        This method deletes any file created by the software,
        whilst downloading data from the AMSIMP Initial Atmospheric
        Conditions Data Repository. It does not, however, delete any
        forecast generated by, the, atmospheric_prognostic_method, method.
        Please note that you may specifcy whether you would like to save
        such files throught the utilisation of the parameter, remove_files,
        when the class is initialised.
        """
        # Initial atmospheric conditions file.
        try:
            os.remove("initial_conditions.nc")
        except OSError:
            pass
        
        # Close Python.
        sys.exit()

# -----------------------------------------------------------------------------------------#

    cpdef np.ndarray pressure_thickness(self, p1=1000, p2=500):
        """
        Generates a NumPy array of pressure thickness between two defined
        constant pressure surfaces.

        Pressure thickness is defined as the distance between two
        pressure surfaces. Pressure thickness is determined through the
        hypsometric equation.

        Equation:
            h = z_2 - z_1
        """
        # Ensure p1 is greater than p2.
        if p1 < p2:
            raise Exception("Please note that p1 must be greater than p2.")

        # Find the nearest constant pressure surface to p1 and p2 in pressure.
        cdef int indx_p1 = (np.abs(self.pressure_surfaces().value - p1)).argmin()
        cdef int indx_p2 = (np.abs(self.pressure_surfaces().value - p2)).argmin()

        pressure_thickness = (
            self.geopotential_height()[indx_p2] - self.geopotential_height()[indx_p1]
        )

        return pressure_thickness

    cpdef np.ndarray troposphere_boundaryline(self):
        """
        Generates a NumPy array of the troposphere - stratosphere
        boundary line in the shape (len(longitude_lines), len(latitude_lines).
        This is calculated by looking at the vertical temperature profile in
        the method, amsimp.Backend.temperature().


        """
        cdef np.ndarray temperature = self.temperature().value
        grad_temperature = np.gradient(temperature)
        cdef np.ndarray gradient_temperature = grad_temperature[0]
        gradient_temperature = np.transpose(gradient_temperature, (2, 1, 0))

        cdef np.ndarray psurface = self.pressure_surfaces().value

        cdef list trop_strat_line = []
        cdef list lat_trop_strat_line
        cdef np.ndarray temp, t
        cdef int n
        cdef float t_n, p
        for temp in gradient_temperature:
            lat_trop_strat_line = []
            for t in temp:
                n = 0
                while n < len(t):
                    t_n = t[n]
                    if t[n] >= 0:
                        p = psurface[n]
                        if p < 400:
                            lat_trop_strat_line.append(p)
                            n = len(t)
                    n += 1
            trop_strat_line.append(lat_trop_strat_line)

        troposphere_boundaryline = np.asarray(trop_strat_line)
        troposphere_boundaryline = np.transpose(troposphere_boundaryline, (1, 0)) 
        troposphere_boundaryline *= units.hPa
        return troposphere_boundaryline

# -----------------------------------------------------------------------------------------#

    def longitude_contourf(self, which="air_temperature", psurface=1000):
        """
        Plots a desired atmospheric process on a contour plot, with the axes
        being latitude and longitude. This plot is then layed on top of a
        EckertIII global projection. 
        
        For the raw data, please see the other methods found in this class.

        If you would like a particular atmospheric process to
        be added to this method, either create an issue on
        GitHub or send an email to support@amsimp.com.
        """        
        # Ensure, which, is a string.
        if not isinstance(which, str):
            raise Exception(
                "which must be a string of the name of the atmospheric parameter of interest."
            )

        # Index of the nearest pressure surface in amsimp.Backend.pressure_surfaces()
        indx_psurface = (np.abs(self.pressure_surfaces().value - psurface)).argmin()
        
        # Defines the axes, and the data.
        latitude, longitude = np.meshgrid(
            self.latitude_lines().value,
            self.longitude_lines().value
        )

        if which == "temperature" or which == "air_temperature":
            data = self.temperature()[indx_psurface, :, :]
            data_type = "Air Temperature"
            unit = " (K)"
        elif which == "geopotential_height" or which == "height":
            data = self.geopotential_height()[indx_psurface, :, :]
            data_type = "Geopotential Height"
            unit = " (m)"
        elif which == "density" or which == "atmospheric_density":
            data = self.density()[indx_psurface, :, :]
            data_type = "Atmospheric Density"
            unit = " ($\\frac{kg}{m^3}$)"
        elif which == "humidity" or which == "relative_humidity":
            data = self.relative_humidity()[indx_psurface, :, :]
            data_type = "Relative Humidity"
            unit = " (%)"
        elif which == "virtual_temperature":
            data = self.virtual_temperature()[indx_psurface, :, :]
            data_type = "Virtual Temperature"
            unit = " (K)"
        elif which == "vapor_pressure":
            data = self.vapor_pressure()[indx_psurface, :, :]
            data_type = "Vapor Pressure"
            unit = " (hPa)"
        elif which == "potential_temperature":
            data = self.potential_temperature()[indx_psurface, :, :]
            data_type = "Potential Temperature"
            unit = " (K)"
        elif which == "precipitable_water" or which == "precipitable_water_vapor":
            data = self.precipitable_water()
            data_type = "Precipitable Water Vapor"
            unit = " (mm)"
        elif which == "zonal_wind":
            data = self.wind()[0][indx_psurface, :, :]
            data_type = "Zonal Wind"
            unit = " ($\\frac{m}{s}$)"
        elif which == "meridional_wind":
            data = self.wind()[1][indx_psurface, :, :]
            data_type = "Meridional Wind"
            unit = " ($\\frac{m}{s}$)"
        elif which == "wind":
            data = self.wind()
            data = np.sqrt(data[0]**2 + data[1]**2)[indx_psurface, :, :]
            data_type = "Wind"
            unit = " ($\\frac{m}{s}$)"
        elif which == "mixing_ratio":
            data = self.mixing_ratio()[indx_psurface, :, :]
            data_type = "Mixing Ratio"
            unit = " (Dimensionless)"
        else:
            raise Exception(
                "Invalid keyword. which must be a string of an atmospheric parameter included with AMSIMP."
            )

        if psurface < self.pressure_surfaces()[-1].value or psurface > self.pressure_surfaces()[0].value:
            raise Exception(
                "psurface must be a real number within the isobaric boundaries. The value of psurface was: {}".format(
                    psurface
                )
            )

        # EckertIII projection details.
        ax = plt.axes(projection=ccrs.EckertIII())
        ax.set_global()
        ax.coastlines()
        ax.gridlines()

        # Contourf plotting.
        minimum = data.min()
        maximum = data.max()
        levels = np.linspace(minimum, maximum, 21)
        data, lon = add_cyclic_point(data, coord=self.longitude_lines().value)
        contour = plt.contourf(
            lon,
            self.latitude_lines().value,
            data,
            transform=ccrs.PlateCarree(),
            levels=levels,
        )

        # Add SALT.
        plt.xlabel("Latitude ($\phi$)")
        plt.ylabel("Longitude ($\lambda$)")
        if not self.input_data:
            title = (
                data_type + " ("
                + str(self.date.year) + '-' + str(self.date.month) + '-'
                + str(self.date.day) + " " + str(self.date.hour)
                + ":00 h)"
            )
        else:
            title = data_type
    
        if which != "surface_temperature" and which != "precipitable_water" and which != "precipitable_water_vapor":
            title = (
                title + " (" + "Pressure Surface = " + str(self.pressure_surfaces()[indx_psurface]) +")"
            )

        plt.title(title)

        # Colorbar creation.
        colorbar = plt.colorbar()
        tick_locator = ticker.MaxNLocator(nbins=15)
        colorbar.locator = tick_locator
        colorbar.update_ticks()
        colorbar.set_label(
            data_type + unit
        )

        plt.show()
        plt.close()
    
    def psurface_contourf(self, which="air_temperature", central_long=352.3079):
        """
        Plots a desired atmospheric process on a contour plot,
        with the axes being latitude, and pressure surfaces. 
        
        For the raw data, please see the other methods found in
        this class.
        
        If you would like a particular atmospheric process to
        be added to this method, either create an issue on
        GitHub or send an email to support@amsimp.com.
        """
        # Ensure, which, is a string.
        if not isinstance(which, str):
            raise Exception(
                "which must be a string of the name of the atmospheric parameter of interest."
            )
        
        # Ensure central_long is between 0 and 359.
        if central_long < 0 or central_long > 359:
            raise Exception(
                "central_long must be a real number between 0 and 359. The value of central_long was: {}".format(
                    central_long
                )
            )
        
        # Index of the nearest central_long in amsimp.Backend.longtitude_lines()
        indx_long = (np.abs(self.longitude_lines().value - central_long)).argmin()

        # Defines the axes, and the data.
        latitude, pressure_surfaces = np.meshgrid(
            self.latitude_lines().value, self.pressure_surfaces()
        )
        
        if which == "temperature" or which == "air_temperature":
            data = self.temperature()[:, :, indx_long]
            data_type = "Air Temperature"
            unit = " (K)"
        elif which == "density" or which == "atmospheric_density":
            data = self.density()[:, :, indx_long]
            data_type = "Atmospheric Density"
            unit = " ($\\frac{kg}{m^3}$)"
        elif which == "humidity" or which == "relative_humidity":
            data = self.relative_humidity()[:, :, indx_long]
            data_type = "Relative Humidity"
            unit = " (%)"
        elif which == "virtual_temperature":
            data = self.virtual_temperature()[:, :, indx_long]
            data_type = "Virtual Temperature"
            unit = " (K)"
        elif which == "vapor_pressure":
            data = self.vapor_pressure()[:, :, indx_long]
            data_type = "Vapor Pressure"
            unit = " (hPa)"
        elif which == "potential_temperature":
            data = self.potential_temperature()[:, :, indx_long]
            data_type = "Potential Temperature"
            unit = " (K)"
        elif which == "zonal_wind":
            data = self.wind()[0][:, :, indx_long]
            data_type = "Zonal Wind"
            unit = " ($\\frac{m}{s}$)"
        elif which == "meridional_wind":
            data = self.wind()[1][:, :, indx_long]
            data_type = "Meridional Wind"
            unit = " ($\\frac{m}{s}$)"
        elif which == "mixing_ratio":
            data = self.mixing_ratio()[:, :, indx_long]
            data_type = "Mixing Ratio"
            unit = " (Dimensionless)"
        else:
            raise Exception(
                "Invalid keyword. which must be a string of an atmospheric parameter included with AMSIMP."
            )

        # Contourf plotting.
        minimum = data.min()
        maximum = data.max()
        levels = np.linspace(minimum, maximum, 21)
        plt.contourf(
            latitude,
            pressure_surfaces,
            data,
            levels=levels,
        )

        # Add SALT.
        plt.xlabel("Latitude ($\phi$)")
        plt.ylabel("Pressure (hPa)")
        plt.yscale('log')
        plt.gca().invert_yaxis()
        if not self.input_data:
            plt.title(
                data_type + " ("
                + str(self.date.year) + '-' + str(self.date.month) + '-'
                + str(self.date.day) + " " + str(self.date.hour)
                + ":00 h, Longitude = "
                + str(np.round(self.longitude_lines()[indx_long], 2)) + ")"
            )
        else:
            plt.title(
                data_type + " ("
                + "Longitude = "
                + str(np.round(self.longitude_lines()[indx_long], 2)) + ")"
            )

        # Colorbar creation.
        colorbar = plt.colorbar()
        tick_locator = ticker.MaxNLocator(nbins=15)
        colorbar.locator = tick_locator
        colorbar.update_ticks()
        colorbar.set_label(
            data_type + unit
        )

        # Average boundary line between the troposphere and the stratosphere.
        troposphere_boundaryline = self.troposphere_boundaryline()
        avg_tropstratline = np.mean(troposphere_boundaryline) + np.zeros(
            len(troposphere_boundaryline)
        )

        # Plot average boundary line on the contour plot.
        plt.plot(
            latitude[1],
            avg_tropstratline,
            color="black",
            linestyle="dashed",
            label="Troposphere - Stratosphere Boundary Line",
        )
        plt.legend(loc=0)

        plt.show()
        plt.close()
    
    def thickness_contourf(self, p1=1000, p2=500):
        """
        Plots pressure thickness on a contour plot, with the axes being
        latitude and longitude. This plot is then layed on top of a EckertIII
        global projection. 
        
        For the raw data, please use the amsimp.Backend.pressure_thickness()
        method.
        """
        # Defines the axes, and the data.
        latitude, longitude = self.latitude_lines().value, self.longitude_lines().value

        cdef np.ndarray pressure_thickness = self.pressure_thickness(p1=p1, p2=p2)

        # EckertIII projection details.
        ax = plt.axes(projection=ccrs.EckertIII())
        ax.set_global()
        ax.coastlines()
        ax.gridlines()

        # Contourf plotting.
        minimum = pressure_thickness.min()
        maximum = pressure_thickness.max()
        levels = np.linspace(minimum, maximum, 21)
        pressure_thickness, longitude = add_cyclic_point(
            pressure_thickness, coord=longitude
        )
        contour = plt.contourf(
            longitude,
            latitude,
            pressure_thickness,
            transform=ccrs.PlateCarree(),
            levels=levels,
        )

        # Index of the rain / snow line
        indx_snowline = (np.abs(levels.value - 5400)).argmin()
        contour.collections[indx_snowline].set_color('black')
        contour.collections[indx_snowline].set_linewidth(1) 

        # Add SALT.
        plt.xlabel("Latitude ($\phi$)")
        plt.ylabel("Longitude ($\lambda$)")
        if not self.input_data:
            plt.title("Pressure Thickness ("
                + str(self.date.year) + '-' + str(self.date.month) + '-'
                + str(self.date.day) + " " + str(self.date.hour) + ":00 h" + ")"
            )
        else:
            plt.title("Pressure Thickness")

        # Colorbar creation.
        colorbar = plt.colorbar()
        tick_locator = ticker.MaxNLocator(nbins=15)
        colorbar.locator = tick_locator
        colorbar.update_ticks()
        colorbar.set_label(
            "Pressure Thickness (" + str(p1) + " hPa - " + str(p2) + " hPa) (m)"
        )

        # Footnote
        if p1 == 1000 and p2 == 500:
            plt.figtext(
                0.99,
                0.01,
                "Rain / Snow Line is marked by the black line (5,400 m).",
                horizontalalignment="right",
            )

        plt.show()
        plt.close()
